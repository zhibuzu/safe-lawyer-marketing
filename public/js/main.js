/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/js/splide.esm.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/js/splide.esm.js ***!
  \********************************************************************************************************/
/***/ ((module) => {

eval("/*!\n * Splide.js\n * Version  : 2.4.20\n * License  : MIT\n * Copyright: 2020 Naotoshi Fujita\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 311:\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_627__) => {\n\n// ESM COMPAT FLAG\n__nested_webpack_require_627__.r(__webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_627__.d(__webpack_exports__, {\n  \"default\": () => /* binding */ module_Splide\n});\n\n// NAMESPACE OBJECT: ./src/js/constants/states.js\nvar states_namespaceObject = {};\n__nested_webpack_require_627__.r(states_namespaceObject);\n__nested_webpack_require_627__.d(states_namespaceObject, {\n  \"CREATED\": () => CREATED,\n  \"DESTROYED\": () => DESTROYED,\n  \"IDLE\": () => IDLE,\n  \"MOUNTED\": () => MOUNTED,\n  \"MOVING\": () => MOVING\n});\n\n;// CONCATENATED MODULE: ./src/js/core/event.js\n/**\r\n * The function for providing an Event object simply managing events.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function for providing an Event object simply managing events.\r\n */\n/* harmony default export */ const core_event = (function () {\n  /**\r\n   * Store all event data.\r\n   *\r\n   * @type {Array}\r\n   */\n  var data = [];\n  var Event = {\n    /**\r\n     * Subscribe the given event(s).\r\n     *\r\n     * @param {string}   events  - An event name. Use space to separate multiple events.\r\n     *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n     * @param {function} handler - A callback function.\r\n     * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n     * @param {Object}   options - Optional. Options for addEventListener.\r\n     */\n    on: function on(events, handler, elm, options) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      events.split(' ').forEach(function (event) {\n        if (elm) {\n          elm.addEventListener(event, handler, options);\n        }\n\n        data.push({\n          event: event,\n          handler: handler,\n          elm: elm,\n          options: options\n        });\n      });\n    },\n\n    /**\r\n     * Unsubscribe the given event(s).\r\n     *\r\n     * @param {string}  events - A event name or names split by space.\r\n     * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n     */\n    off: function off(events, elm) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      events.split(' ').forEach(function (event) {\n        data = data.filter(function (item) {\n          if (item && item.event === event && item.elm === elm) {\n            unsubscribe(item);\n            return false;\n          }\n\n          return true;\n        });\n      });\n    },\n\n    /**\r\n     * Emit an event.\r\n     * This method is only for custom events.\r\n     *\r\n     * @param {string}  event - An event name.\r\n     * @param {*}       args  - Any number of arguments passed to handlers.\r\n     */\n    emit: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      data.forEach(function (item) {\n        if (!item.elm && item.event.split('.')[0] === event) {\n          item.handler.apply(item, args);\n        }\n      });\n    },\n\n    /**\r\n     * Clear event data.\r\n     */\n    destroy: function destroy() {\n      data.forEach(unsubscribe);\n      data = [];\n    }\n  };\n  /**\r\n   * Remove the registered event listener.\r\n   *\r\n   * @param {Object} item - An object containing event data.\r\n   */\n\n  function unsubscribe(item) {\n    if (item.elm) {\n      item.elm.removeEventListener(item.event, item.handler, item.options);\n    }\n  }\n\n  return Event;\n});\n;// CONCATENATED MODULE: ./src/js/core/state.js\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @param {string|number} initialState - Provide the initial state value.\r\n */\n/* harmony default export */ const state = (function (initialState) {\n  /**\r\n   * Store the current state.\r\n   *\r\n   * @type {string|number}\r\n   */\n  var curr = initialState;\n  return {\n    /**\r\n     * Change state.\r\n     *\r\n     * @param {string|number} state - A new state.\r\n     */\n    set: function set(state) {\n      curr = state;\n    },\n\n    /**\r\n     * Verify if the current state is given one or not.\r\n     *\r\n     * @param {string|number} state - A state name to be verified.\r\n     *\r\n     * @return {boolean} - True if the current state is the given one.\r\n     */\n    is: function is(state) {\n      return state === curr;\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/object.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\r\n * Some utility functions related with Object, supporting IE.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\nvar keys = Object.keys;\n/**\r\n * Iterate an object like Array.forEach.\r\n * IE doesn't support forEach of HTMLCollection.\r\n *\r\n * @param {Object}    obj       - An object.\r\n * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n */\n\nfunction each(obj, callback) {\n  keys(obj).some(function (key, index) {\n    return callback(obj[key], key, index);\n  });\n}\n/**\r\n * Return values of the given object as an array.\r\n * IE doesn't support Object.values.\r\n *\r\n * @param {Object} obj - An object.\r\n *\r\n * @return {Array} - An array containing all values of the given object.\r\n */\n\nfunction values(obj) {\n  return keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n/**\r\n * Check if the given subject is object or not.\r\n *\r\n * @param {*} subject - A subject to be verified.\r\n *\r\n * @return {boolean} - True if object, false otherwise.\r\n */\n\nfunction isObject(subject) {\n  return typeof subject === 'object';\n}\n/**\r\n * Merge two objects deeply.\r\n *\r\n * @param {Object} to   - An object where \"from\" is merged.\r\n * @param {Object} from - An object merged to \"to\".\r\n *\r\n * @return {Object} - A merged object.\r\n */\n\nfunction merge(_ref, from) {\n  var to = _extends({}, _ref);\n\n  each(from, function (value, key) {\n    if (isObject(value)) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n\n      to[key] = merge(to[key], value);\n    } else {\n      to[key] = value;\n    }\n  });\n  return to;\n}\n/**\r\n * Assign all properties \"from\" to \"to\" object.\r\n *\r\n * @param {Object} to   - An object where properties are assigned.\r\n * @param {Object} from - An object whose properties are assigned to \"to\".\r\n *\r\n * @return {Object} - An assigned object.\r\n */\n\nfunction object_assign(to, from) {\n  keys(from).forEach(function (key) {\n    if (!to[key]) {\n      Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\n    }\n  });\n  return to;\n}\n;// CONCATENATED MODULE: ./src/js/utils/utils.js\n/**\r\n * A package of some miscellaneous utility functions.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Convert the given value to array.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @return {*[]} - Array containing the given value.\r\n */\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/**\r\n * Check if the given value is between min and max.\r\n * Min will be returned when the value is less than min or max will do when greater than max.\r\n *\r\n * @param {number} value - A number to be checked.\r\n * @param {number} m1    - Minimum or maximum number.\r\n * @param {number} m2    - Maximum or minimum number.\r\n *\r\n * @return {number} - A value itself, min or max.\r\n */\n\nfunction between(value, m1, m2) {\n  return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\n}\n/**\r\n * The sprintf method with minimum functionality.\r\n *\r\n * @param {string}       format       - The string format.\r\n * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n *\r\n * @returns {string} - Converted string.\r\n */\n\nfunction sprintf(format, replacements) {\n  var i = 0;\n  return format.replace(/%s/g, function () {\n    return toArray(replacements)[i++];\n  });\n}\n/**\r\n * Append px unit to the given subject if necessary.\r\n *\r\n * @param {number|string} value - A value that may not include an unit.\r\n *\r\n * @return {string} - If the value is string, return itself.\r\n *                    If number, do value + \"px\". An empty string, otherwise.\r\n */\n\nfunction unit(value) {\n  var type = typeof value;\n\n  if (type === 'number' && value > 0) {\n    return parseFloat(value) + 'px';\n  }\n\n  return type === 'string' ? value : '';\n}\n/**\r\n * Pad start with 0.\r\n *\r\n * @param {number} number - A number to be filled with 0.\r\n *\r\n * @return {string|number} - Padded number.\r\n */\n\nfunction pad(number) {\n  return number < 10 ? '0' + number : number;\n}\n/**\r\n * Convert the given value to pixel.\r\n *\r\n * @param {Element}       root  - Root element where a dummy div is appended.\r\n * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n *\r\n * @return {number} - Pixel.\r\n */\n\nfunction toPixel(root, value) {\n  if (typeof value === 'string') {\n    var div = create('div', {});\n    applyStyle(div, {\n      position: 'absolute',\n      width: value\n    });\n    append(root, div);\n    value = div.clientWidth;\n    dom_remove(div);\n  }\n\n  return +value || 0;\n}\n;// CONCATENATED MODULE: ./src/js/utils/dom.js\n/**\r\n * Some utility functions related with DOM.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Find the first element matching the given selector.\r\n * Be aware that all selectors after a space are ignored.\r\n *\r\n * @param {Element|Node}  elm       - An ancestor element.\r\n * @param {string}        selector  - DOMString.\r\n *\r\n * @return {Element|null} - A found element or null.\r\n */\n\nfunction find(elm, selector) {\n  return elm ? elm.querySelector(selector.split(' ')[0]) : null;\n}\n/**\r\n * Find a first child having the given tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element|undefined} - A found element on success or undefined on failure.\r\n */\n\nfunction child(parent, tagOrClassName) {\n  return children(parent, tagOrClassName)[0];\n}\n/**\r\n * Return chile elements that matches the provided tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element[]} - Found elements.\r\n */\n\nfunction children(parent, tagOrClassName) {\n  if (parent) {\n    return values(parent.children).filter(function (child) {\n      return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\n    });\n  }\n\n  return [];\n}\n/**\r\n * Create an element with some optional attributes.\r\n *\r\n * @param {string} tag   - A tag name.\r\n * @param {Object} attrs - An object any attribute pairs of name and value.\r\n *\r\n * @return {Element} - A created element.\r\n */\n\nfunction create(tag, attrs) {\n  var elm = document.createElement(tag);\n  each(attrs, function (value, key) {\n    return setAttribute(elm, key, value);\n  });\n  return elm;\n}\n/**\r\n * Convert HTML string to DOM node.\r\n *\r\n * @param {string} html - HTML string.\r\n *\r\n * @return {Node} - A created node.\r\n */\n\nfunction domify(html) {\n  var div = create('div', {});\n  div.innerHTML = html;\n  return div.firstChild;\n}\n/**\r\n * Remove a given element from a DOM tree.\r\n *\r\n * @param {Element|Element[]} elms - Element(s) to be removed.\r\n */\n\nfunction dom_remove(elms) {\n  toArray(elms).forEach(function (elm) {\n    if (elm) {\n      var parent = elm.parentElement;\n      parent && parent.removeChild(elm);\n    }\n  });\n}\n/**\r\n * Append a child to a given element.\r\n *\r\n * @param {Element} parent - A parent element.\r\n * @param {Element} child  - An element to be appended.\r\n */\n\nfunction append(parent, child) {\n  if (parent) {\n    parent.appendChild(child);\n  }\n}\n/**\r\n * Insert an element before the reference element.\r\n *\r\n * @param {Element|Node} ref - A reference element.\r\n * @param {Element}      elm - An element to be inserted.\r\n */\n\nfunction before(elm, ref) {\n  if (elm && ref) {\n    var parent = ref.parentElement;\n    parent && parent.insertBefore(elm, ref);\n  }\n}\n/**\r\n * Apply styles to the given element.\r\n *\r\n * @param {Element} elm     - An element where styles are applied.\r\n * @param {Object}  styles  - Object containing styles.\r\n */\n\nfunction applyStyle(elm, styles) {\n  if (elm) {\n    each(styles, function (value, prop) {\n      if (value !== null) {\n        elm.style[prop] = value;\n      }\n    });\n  }\n}\n/**\r\n * Add or remove classes to/from the element.\r\n * This function is for internal usage.\r\n *\r\n * @param {Element}         elm     - An element where classes are added.\r\n * @param {string|string[]} classes - Class names being added.\r\n * @param {boolean}         remove  - Whether to remove or add classes.\r\n */\n\nfunction addOrRemoveClasses(elm, classes, remove) {\n  if (elm) {\n    toArray(classes).forEach(function (name) {\n      if (name) {\n        elm.classList[remove ? 'remove' : 'add'](name);\n      }\n    });\n  }\n}\n/**\r\n * Add classes to the element.\r\n *\r\n * @param {Element}          elm     - An element where classes are added.\r\n * @param {string|string[]}  classes - Class names being added.\r\n */\n\n\nfunction addClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, false);\n}\n/**\r\n * Remove a class from the element.\r\n *\r\n * @param {Element}         elm     - An element where classes are removed.\r\n * @param {string|string[]} classes - A class name being removed.\r\n */\n\nfunction removeClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, true);\n}\n/**\r\n * Verify if the provided element has the class or not.\r\n *\r\n * @param {Element} elm       - An element.\r\n * @param {string}  className - A class name.\r\n *\r\n * @return {boolean} - True if the element has the class or false if not.\r\n */\n\nfunction hasClass(elm, className) {\n  return !!elm && elm.classList.contains(className);\n}\n/**\r\n * Set attribute to the given element.\r\n *\r\n * @param {Element}                 elm   - An element where an attribute is assigned.\r\n * @param {string}                  name  - Attribute name.\r\n * @param {string|number|boolean}   value - Attribute value.\r\n */\n\nfunction setAttribute(elm, name, value) {\n  if (elm) {\n    elm.setAttribute(name, value);\n  }\n}\n/**\r\n * Get attribute from the given element.\r\n *\r\n * @param {Element} elm  - An element where an attribute is assigned.\r\n * @param {string}  name - Attribute name.\r\n *\r\n * @return {string} - The value of the given attribute if available. An empty string if not.\r\n */\n\nfunction getAttribute(elm, name) {\n  return elm ? elm.getAttribute(name) : '';\n}\n/**\r\n * Remove attribute from the given element.\r\n *\r\n * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n * @param {string|string[]}      names - Attribute name.\r\n */\n\nfunction removeAttribute(elms, names) {\n  toArray(names).forEach(function (name) {\n    toArray(elms).forEach(function (elm) {\n      return elm && elm.removeAttribute(name);\n    });\n  });\n}\n/**\r\n * Return the Rect object of the provided object.\r\n *\r\n * @param {Element} elm - An element.\r\n *\r\n * @return {ClientRect|DOMRect} - A rect object.\r\n */\n\nfunction getRect(elm) {\n  return elm.getBoundingClientRect();\n}\n/**\r\n * Trigger the given callback after all images contained by the element are loaded.\r\n *\r\n * @param {Element}  elm      - Element that may contain images.\r\n * @param {Function} callback - Callback function fired right after all images are loaded.\r\n */\n\nfunction loaded(elm, callback) {\n  var images = elm.querySelectorAll('img');\n  var length = images.length;\n\n  if (length) {\n    var count = 0;\n    each(images, function (img) {\n      img.onload = img.onerror = function () {\n        if (++count === length) {\n          callback();\n        }\n      };\n    });\n  } else {\n    // Trigger the callback immediately if there is no image.\n    callback();\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/types.js\n/**\r\n * Export slider types.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Normal slider.\r\n *\r\n * @type {string}\r\n */\nvar SLIDE = 'slide';\n/**\r\n * Loop after the last slide and before the first one.\r\n *\r\n * @type {string}\r\n */\n\nvar LOOP = 'loop';\n/**\r\n * The track doesn't move.\r\n *\r\n * @type {string}\r\n */\n\nvar FADE = 'fade';\n;// CONCATENATED MODULE: ./src/js/transitions/slide/index.js\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const slide = (function (Splide, Components) {\n  /**\r\n   * Hold the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var list;\n  /**\r\n   * Hold the onEnd callback function.\r\n   *\r\n   * @type {function}\r\n   */\n\n  var endCallback;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      list = Components.Elements.list;\n      Splide.on('transitionend', function (e) {\n        if (e.target === list && endCallback) {\n          endCallback();\n        }\n      }, list);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}   destIndex - Destination slide index that might be clone's.\r\n     * @param {number}   newIndex  - New index.\r\n     * @param {number}   prevIndex - Previous index.\r\n     * @param {Object}   coord     - Destination coordinates.\r\n     * @param {function} done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var options = Splide.options;\n      var edgeIndex = Components.Controller.edgeIndex;\n      var speed = options.speed;\n      endCallback = done;\n\n      if (Splide.is(SLIDE)) {\n        if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\n          speed = options.rewindSpeed || speed;\n        }\n      }\n\n      applyStyle(list, {\n        transition: \"transform \" + speed + \"ms \" + options.easing,\n        transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/transitions/fade/index.js\n/**\r\n * The component for fade transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for fade transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const fade = (function (Splide, Components) {\n  var Fade = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Apply transition style to the first slide.\r\n     */\n    mount: function mount() {\n      apply(Splide.index);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}    destIndex - Destination slide index that might be clone's.\r\n     * @param {number}    newIndex  - New index.\r\n     * @param {number}    prevIndex - Previous index.\r\n     * @param {Object}    coord     - Destination coordinates.\r\n     * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var track = Components.Elements.track;\n      applyStyle(track, {\n        height: unit(track.clientHeight)\n      });\n      apply(newIndex);\n      setTimeout(function () {\n        done();\n        applyStyle(track, {\n          height: ''\n        });\n      });\n    }\n  };\n  /**\r\n   * Apply transition style to the slide specified by the given index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n\n  function apply(index) {\n    var options = Splide.options;\n    applyStyle(Components.Elements.slides[index], {\n      transition: \"opacity \" + options.speed + \"ms \" + options.easing\n    });\n  }\n\n  return Fade;\n});\n;// CONCATENATED MODULE: ./src/js/transitions/index.js\n/**\r\n * Export transition components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n;// CONCATENATED MODULE: ./src/js/core/composer.js\n/**\r\n * Provide a function for composing components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * Compose components.\r\n *\r\n * @param {Splide}   Splide     - Splide instance.\r\n * @param {Object}   Components - Additional components.\r\n * @param {function} Transition - Change component for transition.\r\n *\r\n * @return {Object} - An object containing all components.\r\n */\n\nfunction compose(Splide, Components, Transition) {\n  var components = {};\n  each(Components, function (Component, name) {\n    components[name] = Component(Splide, components, name.toLowerCase());\n  });\n\n  if (!Transition) {\n    Transition = Splide.is(FADE) ? fade : slide;\n  }\n\n  components.Transition = Transition(Splide, components);\n  return components;\n}\n;// CONCATENATED MODULE: ./src/js/utils/error.js\n/**\r\n * Utility functions for outputting logs.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Prefix of an error massage.\r\n *\r\n * @type {string}\r\n */\nvar MESSAGE_PREFIX = '[SPLIDE]';\n/**\r\n * Display an error message on the browser console.\r\n *\r\n * @param {string} message - An error message.\r\n */\n\nfunction error(message) {\n  console.error(MESSAGE_PREFIX + \" \" + message);\n}\n/**\r\n * Check existence of the given object and throw an error if it doesn't.\r\n *\r\n * @throws {Error}\r\n *\r\n * @param {*}      subject - A subject to be confirmed.\r\n * @param {string} message - An error message.\r\n */\n\nfunction exist(subject, message) {\n  if (!subject) {\n    throw new Error(message);\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/classes.js\n/**\r\n * Export class names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * A root class name.\r\n *\r\n * @type {string}\r\n */\nvar ROOT = 'splide';\n/**\r\n * The definition table of all classes for elements.\r\n * They might be modified by options.\r\n *\r\n * @type {Object}\r\n */\n\nvar ELEMENT_CLASSES = {\n  root: ROOT,\n  slider: ROOT + \"__slider\",\n  track: ROOT + \"__track\",\n  list: ROOT + \"__list\",\n  slide: ROOT + \"__slide\",\n  container: ROOT + \"__slide__container\",\n  arrows: ROOT + \"__arrows\",\n  arrow: ROOT + \"__arrow\",\n  prev: ROOT + \"__arrow--prev\",\n  next: ROOT + \"__arrow--next\",\n  pagination: ROOT + \"__pagination\",\n  page: ROOT + \"__pagination__page\",\n  clone: ROOT + \"__slide--clone\",\n  progress: ROOT + \"__progress\",\n  bar: ROOT + \"__progress__bar\",\n  autoplay: ROOT + \"__autoplay\",\n  play: ROOT + \"__play\",\n  pause: ROOT + \"__pause\",\n  spinner: ROOT + \"__spinner\",\n  sr: ROOT + \"__sr\"\n};\n/**\r\n * Definitions of status classes.\r\n *\r\n * @type {Object}\r\n */\n\nvar STATUS_CLASSES = {\n  active: 'is-active',\n  visible: 'is-visible',\n  loading: 'is-loading'\n};\n;// CONCATENATED MODULE: ./src/js/constants/i18n.js\n/**\r\n * Export i18n texts as object.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Texts for i18n.\r\n *\r\n * @type {Object}\r\n */\nvar I18N = {\n  prev: 'Previous slide',\n  next: 'Next slide',\n  first: 'Go to first slide',\n  last: 'Go to last slide',\n  slideX: 'Go to slide %s',\n  pageX: 'Go to page %s',\n  play: 'Start autoplay',\n  pause: 'Pause autoplay'\n};\n;// CONCATENATED MODULE: ./src/js/constants/defaults.js\n/**\r\n * Export default options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\nvar DEFAULTS = {\n  /**\r\n   * Determine a slider type.\r\n   * - 'slide': Regular slider.\r\n   * - 'loop' : Carousel slider.\r\n   * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n   *\r\n   * @type {string}\r\n   */\n  type: 'slide',\n\n  /**\r\n   * Whether to rewind a slider before the first slide or after the last one.\r\n   * In \"loop\" mode, this option is ignored.\r\n   *\r\n   * @type {boolean}\r\n   */\n  rewind: false,\n\n  /**\r\n   * Transition speed in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  speed: 400,\n\n  /**\r\n   * Transition speed on rewind in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  rewindSpeed: 0,\n\n  /**\r\n   * Whether to prevent any actions while a slider is transitioning.\r\n   * If false, navigation, drag and swipe work while the slider is running.\r\n   * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n   *\r\n   * @type {boolean}\r\n   */\n  waitForTransition: true,\n\n  /**\r\n   * Define slider max width.\r\n   *\r\n   * @type {number}\r\n   */\n  width: 0,\n\n  /**\r\n   * Define slider height.\r\n   *\r\n   * @type {number}\r\n   */\n  height: 0,\n\n  /**\r\n   * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n   * perPage number will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedWidth: 0,\n\n  /**\r\n   * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n   * heightRatio option will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedHeight: 0,\n\n  /**\r\n   * Determine height of slides by ratio to a slider width.\r\n   * This will be ignored when the fixedHeight is provided.\r\n   *\r\n   * @type {number}\r\n   */\n  heightRatio: 0,\n\n  /**\r\n   * If true, slide width will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoWidth: false,\n\n  /**\r\n   * If true, slide height will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoHeight: false,\n\n  /**\r\n   * Determine how many slides should be displayed per page.\r\n   *\r\n   * @type {number}\r\n   */\n  perPage: 1,\n\n  /**\r\n   * Determine how many slides should be moved when a slider goes to next or perv.\r\n   *\r\n   * @type {number}\r\n   */\n  perMove: 0,\n\n  /**\r\n   * Determine manually how many clones should be generated on the left and right side.\r\n   * The total number of clones will be twice of this number.\r\n   *\r\n   * @type {number}\r\n   */\n  clones: 0,\n\n  /**\r\n   * Start index.\r\n   *\r\n   * @type {number}\r\n   */\n  start: 0,\n\n  /**\r\n   * Determine which slide should be focused if there are multiple slides in a page.\r\n   * A string \"center\" is acceptable for centering slides.\r\n   *\r\n   * @type {boolean|number|string}\r\n   */\n  focus: false,\n\n  /**\r\n   * Gap between slides. CSS format is allowed such as 1em.\r\n   *\r\n   * @type {number|string}\r\n   */\n  gap: 0,\n\n  /**\r\n   * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n   * Give a single value to set a same size for both sides or\r\n   * do an object for different sizes.\r\n   * Also, CSS format is allowed such as 1em.\r\n   *\r\n   * @example\r\n   * - 10: Number\r\n   * - '1em': CSS format.\r\n   * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n   * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n   *\r\n   * @type {number|string|Object}\r\n   */\n  padding: 0,\n\n  /**\r\n   * Whether to append arrows.\r\n   *\r\n   * @type {boolean}\r\n   */\n  arrows: true,\n\n  /**\r\n   * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n   *\r\n   * @type {string}\r\n   */\n  arrowPath: '',\n\n  /**\r\n   * Whether to append pagination(indicator dots) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pagination: true,\n\n  /**\r\n   * Activate autoplay.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoplay: false,\n\n  /**\r\n   * Autoplay interval in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  interval: 5000,\n\n  /**\r\n   * Whether to stop autoplay when a slider is hovered.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnHover: true,\n\n  /**\r\n   * Whether to stop autoplay when a slider elements are focused.\r\n   * True is recommended for accessibility.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnFocus: true,\n\n  /**\r\n   * Whether to reset progress of the autoplay timer when resumed.\r\n   *\r\n   * @type {boolean}\r\n   */\n  resetProgress: true,\n\n  /**\r\n   * Loading images lazily.\r\n   * Image src must be provided by a data-splide-lazy attribute.\r\n   *\r\n   * - false: Do nothing.\r\n   * - 'nearby': Only images around an active slide will be loaded.\r\n   * - 'sequential': All images will be sequentially loaded.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  lazyLoad: false,\n\n  /**\r\n   * This option works only when a lazyLoad option is \"nearby\".\r\n   * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n   *\r\n   * @type {number}\r\n   */\n  preloadPages: 1,\n\n  /**\r\n   * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n   *\r\n   * @type {string}\r\n   */\n  easing: 'cubic-bezier(.42,.65,.27,.99)',\n\n  /**\r\n   * Whether to enable keyboard shortcuts\r\n   * - true or 'global': Listen to keydown event of the document.\r\n   * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n   * - false: Disable keyboard shortcuts.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  keyboard: 'global',\n\n  /**\r\n   * Whether to allow mouse drag and touch swipe.\r\n   *\r\n   * @type {boolean}\r\n   */\n  drag: true,\n\n  /**\r\n   * The angle threshold for drag.\r\n   * The slider starts moving only when the drag angle is less than this threshold.\r\n   *\r\n   * @type {number}\r\n   */\n  dragAngleThreshold: 30,\n\n  /**\r\n   * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n   *\r\n   * @type {number}\r\n   */\n  swipeDistanceThreshold: 150,\n\n  /**\r\n   * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * Around 0.5 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickVelocityThreshold: .6,\n\n  /**\r\n   * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n   * Around 500 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickPower: 600,\n\n  /**\r\n   * Limit a number of pages to move by flick.\r\n   *\r\n   * @type {number}\r\n   */\n  flickMaxPages: 1,\n\n  /**\r\n   * Slider direction.\r\n   * - 'ltr': Left to right.\r\n   * - 'rtl': Right to left.\r\n   * - 'ttb': Top to bottom.\r\n   *\r\n   * @type {string}\r\n   */\n  direction: 'ltr',\n\n  /**\r\n   * Set img src to background-image of its parent element.\r\n   * Images with various sizes can be displayed as same dimension without cropping work.\r\n   * fixedHeight or heightRatio is required.\r\n   *\r\n   * @type {boolean}\r\n   */\n  cover: false,\n\n  /**\r\n   * Whether to enable accessibility(aria and screen reader texts) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  accessibility: true,\n\n  /**\r\n   * Whether to add tabindex=\"0\" to visible slides or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  slideFocus: true,\n\n  /**\r\n   * Determine if a slider is navigation for another.\r\n   * Use \"sync\" API to synchronize two sliders.\r\n   *\r\n   * @type {boolean}\r\n   */\n  isNavigation: false,\n\n  /**\r\n   * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n   *\r\n   * @type {boolean}\r\n   */\n  trimSpace: true,\n\n  /**\r\n   * The \"is-active\" class is added after transition as default.\r\n   * If true, it will be added before move.\r\n   *\r\n   * @type {boolean}\r\n   */\n  updateOnMove: false,\n\n  /**\r\n   * Throttle duration in milliseconds for the resize event.\r\n   *\r\n   * @type {number}\r\n   */\n  throttle: 100,\n\n  /**\r\n   * Whether to destroy a slider or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  destroy: false,\n\n  /**\r\n   * Options for specific breakpoints.\r\n   *\r\n   * @example\r\n   * {\r\n   *   1000: {\r\n   *     perPage: 3,\r\n   *     gap: 20\r\n   *   },\r\n   *   600: {\r\n   *     perPage: 1,\r\n   *     gap: 5,\r\n   *   }\r\n   * }\r\n   *\r\n   * @type {boolean|Object}\r\n   */\n  breakpoints: false,\n\n  /**\r\n   * Collection of class names.\r\n   *\r\n   * @see ./classes.js\r\n   *\r\n   * @type {Object}\r\n   */\n  classes: ELEMENT_CLASSES,\n\n  /**\r\n   * Collection of i18n texts.\r\n   *\r\n   * @see ./i18n.js\r\n   *\r\n   * @type {Object}\r\n   */\n  i18n: I18N\n};\n;// CONCATENATED MODULE: ./src/js/constants/states.js\n/**\r\n * Export state constants.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Splide has been just created.\r\n *\r\n * @type {number}\r\n */\nvar CREATED = 1;\n/**\r\n * All components have been mounted and initialized.\r\n *\r\n * @type {number}\r\n */\n\nvar MOUNTED = 2;\n/**\r\n * Splide is ready for transition.\r\n *\r\n * @type {number}\r\n */\n\nvar IDLE = 3;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar MOVING = 4;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar DESTROYED = 5;\n;// CONCATENATED MODULE: ./src/js/splide.js\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * The main class for applying Splide to an element.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n/**\r\n * The main class for applying Splide to an element,\r\n * providing some APIs to control the behavior.\r\n */\n\nvar Splide = /*#__PURE__*/function () {\n  /**\r\n   * Splide constructor.\r\n   *\r\n   * @throws {Error} When the given root element or selector is invalid.\r\n   *\r\n   * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n   * @param {Object}          options    - Optional. Options to change default behaviour.\r\n   * @param {Object}          Components - Optional. Components.\r\n   */\n  function Splide(root, options, Components) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (Components === void 0) {\n      Components = {};\n    }\n\n    this.root = root instanceof Element ? root : document.querySelector(root);\n    exist(this.root, 'An invalid element/selector was given.');\n    this.Components = null;\n    this.Event = core_event();\n    this.State = state(CREATED);\n    this.STATES = states_namespaceObject;\n    this._o = merge(DEFAULTS, options);\n    this._i = 0;\n    this._c = Components;\n    this._e = {}; // Extensions\n\n    this._t = null; // Transition\n  }\n  /**\r\n   * Compose and mount components.\r\n   *\r\n   * @param {Object}   Extensions - Optional. Additional components.\r\n   * @param {function} Transition - Optional. Set a custom transition component.\r\n   *\r\n   * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n   */\n\n\n  var _proto = Splide.prototype;\n\n  _proto.mount = function mount(Extensions, Transition) {\n    var _this = this;\n\n    if (Extensions === void 0) {\n      Extensions = this._e;\n    }\n\n    if (Transition === void 0) {\n      Transition = this._t;\n    }\n\n    // Reset the state.\n    this.State.set(CREATED);\n    this._e = Extensions;\n    this._t = Transition;\n    this.Components = compose(this, merge(this._c, Extensions), Transition);\n\n    try {\n      each(this.Components, function (component, key) {\n        var required = component.required;\n\n        if (required === undefined || required) {\n          component.mount && component.mount();\n        } else {\n          delete _this.Components[key];\n        }\n      });\n    } catch (e) {\n      error(e.message);\n      return;\n    }\n\n    var State = this.State;\n    State.set(MOUNTED);\n    each(this.Components, function (component) {\n      component.mounted && component.mounted();\n    });\n    this.emit('mounted');\n    State.set(IDLE);\n    this.emit('ready');\n    applyStyle(this.root, {\n      visibility: 'visible'\n    });\n    this.on('move drag', function () {\n      return State.set(MOVING);\n    }).on('moved dragged', function () {\n      return State.set(IDLE);\n    });\n    return this;\n  }\n  /**\r\n   * Set sync target.\r\n   *\r\n   * @param {Splide} splide - A Splide instance.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.sync = function sync(splide) {\n    this.sibling = splide;\n    return this;\n  }\n  /**\r\n   * Register callback fired on the given event(s).\r\n   *\r\n   * @param {string}   events  - An event name. Use space to separate multiple events.\r\n   *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n   * @param {function} handler - A callback function.\r\n   * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n   * @param {Object}   options - Optional. Options for addEventListener.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.on = function on(events, handler, elm, options) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.Event.on(events, handler, elm, options);\n    return this;\n  }\n  /**\r\n   * Unsubscribe the given event.\r\n   *\r\n   * @param {string}  events - A event name.\r\n   * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.off = function off(events, elm) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    this.Event.off(events, elm);\n    return this;\n  }\n  /**\r\n   * Emit an event.\r\n   *\r\n   * @param {string} event - An event name.\r\n   * @param {*}      args  - Any number of arguments passed to handlers.\r\n   */\n  ;\n\n  _proto.emit = function emit(event) {\n    var _this$Event;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\n\n    return this;\n  }\n  /**\r\n   * Go to the slide specified by the given control.\r\n   *\r\n   * @param {string|number} control - A control pattern.\r\n   * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n   */\n  ;\n\n  _proto.go = function go(control, wait) {\n    if (wait === void 0) {\n      wait = this.options.waitForTransition;\n    }\n\n    if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {\n      this.Components.Controller.go(control, false);\n    }\n\n    return this;\n  }\n  /**\r\n   * Verify whether the slider type is the given one or not.\r\n   *\r\n   * @param {string} type - A slider type.\r\n   *\r\n   * @return {boolean} - True if the slider type is the provided type or false if not.\r\n   */\n  ;\n\n  _proto.is = function is(type) {\n    return type === this._o.type;\n  }\n  /**\r\n   * Insert a slide.\r\n   *\r\n   * @param {Element|string} slide - A slide element to be added.\r\n   * @param {number}         index - A slide will be added at the position.\r\n   */\n  ;\n\n  _proto.add = function add(slide, index) {\n    if (index === void 0) {\n      index = -1;\n    }\n\n    this.Components.Elements.add(slide, index, this.refresh.bind(this));\n    return this;\n  }\n  /**\r\n   * Remove the slide designated by the index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n  ;\n\n  _proto.remove = function remove(index) {\n    this.Components.Elements.remove(index);\n    this.refresh();\n    return this;\n  }\n  /**\r\n   * Destroy all Slide objects and clones and recreate them again.\r\n   */\n  ;\n\n  _proto.refresh = function refresh() {\n    this.emit('refresh:before').emit('refresh').emit('resize');\n    return this;\n  }\n  /**\r\n   * Destroy the Splide.\r\n   * \"Completely\" boolean is mainly for breakpoints.\r\n   *\r\n   * @param {boolean} completely - Destroy completely.\r\n   */\n  ;\n\n  _proto.destroy = function destroy(completely) {\n    var _this2 = this;\n\n    if (completely === void 0) {\n      completely = true;\n    }\n\n    // Postpone destroy because it should be done after mount.\n    if (this.State.is(CREATED)) {\n      this.on('ready', function () {\n        return _this2.destroy(completely);\n      });\n      return;\n    }\n\n    values(this.Components).reverse().forEach(function (component) {\n      component.destroy && component.destroy(completely);\n    });\n    this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\n\n    this.Event.destroy();\n    this.State.set(DESTROYED);\n    return this;\n  }\n  /**\r\n   * Return the current slide index.\r\n   *\r\n   * @return {number} - The current slide index.\r\n   // */\n  ;\n\n  _createClass(Splide, [{\n    key: \"index\",\n    get: function get() {\n      return this._i;\n    }\n    /**\r\n     * Set the current slide index.\r\n     *\r\n     * @param {number|string} index - A new index.\r\n     */\n    ,\n    set: function set(index) {\n      this._i = parseInt(index);\n    }\n    /**\r\n     * Return length of slides.\r\n     * This is an alias of Elements.length.\r\n     *\r\n     * @return {number} - A number of slides.\r\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.Components.Elements.length;\n    }\n    /**\r\n     * Return options.\r\n     *\r\n     * @return {Object} - Options object.\r\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._o;\n    }\n    /**\r\n     * Set options with merging the given object to the current one.\r\n     *\r\n     * @param {Object} options - New options.\r\n     */\n    ,\n    set: function set(options) {\n      var created = this.State.is(CREATED);\n\n      if (!created) {\n        this.emit('update');\n      }\n\n      this._o = merge(this._o, options);\n\n      if (!created) {\n        this.emit('updated', this._o);\n      }\n    }\n    /**\r\n     * Return the class list.\r\n     * This is an alias of Splide.options.classList.\r\n     *\r\n     * @return {Object} - An object containing all class list.\r\n     */\n\n  }, {\n    key: \"classes\",\n    get: function get() {\n      return this._o.classes;\n    }\n    /**\r\n     * Return the i18n strings.\r\n     * This is an alias of Splide.options.i18n.\r\n     *\r\n     * @return {Object} - An object containing all i18n strings.\r\n     */\n\n  }, {\n    key: \"i18n\",\n    get: function get() {\n      return this._o.i18n;\n    }\n  }]);\n\n  return Splide;\n}();\n\n\n;// CONCATENATED MODULE: ./src/js/components/options/index.js\n/**\r\n * The component for initializing options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for initializing options.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const options = (function (Splide) {\n  /**\r\n   * Retrieve options from the data attribute.\r\n   * Note that IE10 doesn't support dataset property.\r\n   *\r\n   * @type {string}\r\n   */\n  var options = getAttribute(Splide.root, 'data-splide');\n\n  if (options) {\n    try {\n      Splide.options = JSON.parse(options);\n    } catch (e) {\n      error(e.message);\n    }\n  }\n\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      if (Splide.State.is(CREATED)) {\n        Splide.index = Splide.options.start;\n      }\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/constants/directions.js\n/**\r\n * Export layout modes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Enumerate slides from left to right.\r\n *\r\n * @type {string}\r\n */\nvar LTR = 'ltr';\n/**\r\n * Enumerate slides from right to left.\r\n *\r\n * @type {string}\r\n */\n\nvar RTL = 'rtl';\n/**\r\n * Enumerate slides in a col.\r\n *\r\n * @type {string}\r\n */\n\nvar TTB = 'ttb';\n;// CONCATENATED MODULE: ./src/js/components/elements/slide.js\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n/**\r\n * Events for restoring original styles.\r\n *\r\n * @type {string}\r\n */\n\nvar STYLE_RESTORE_EVENTS = 'update.slide';\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @param {Splide}  Splide    - A Splide instance.\r\n * @param {number}  index     - An unique slide index.\r\n * @param {number}  realIndex - Clones should pass a real slide index.\r\n * @param {Element} slide     - A slide element.\r\n *\r\n * @return {Object} - The sub component object.\r\n */\n\n/* harmony default export */ const elements_slide = (function (Splide, index, realIndex, slide) {\n  /**\r\n   * Whether to update \"is-active\" class before or after transition.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var updateOnMove = Splide.options.updateOnMove;\n  /**\r\n   * Events when the slide status is updated.\r\n   * Append a namespace to remove listeners later.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\n  /**\r\n   * Slide sub component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Slide = {\n    /**\r\n     * Slide element.\r\n     *\r\n     * @type {Element}\r\n     */\n    slide: slide,\n\n    /**\r\n     * Slide index.\r\n     *\r\n     * @type {number}\r\n     */\n    index: index,\n\n    /**\r\n     * Real index for clones.\r\n     *\r\n     * @type {number}\r\n     */\n    realIndex: realIndex,\n\n    /**\r\n     * Container element if available.\r\n     *\r\n     * @type {Element|undefined}\r\n     */\n    container: child(slide, Splide.classes.container),\n\n    /**\r\n     * Whether this is a cloned slide or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    isClone: realIndex > -1,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (!this.isClone) {\n        slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\n      }\n\n      Splide.on(STATUS_UPDATE_EVENTS, function () {\n        return _this.update();\n      }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\n        return Splide.emit('click', _this);\n      }, slide);\n      /*\r\n       * Add \"is-active\" class to a clone element temporarily\r\n       * and it will be removed on \"moved\" event.\r\n       */\n\n      if (updateOnMove) {\n        Splide.on('move.slide', function (newIndex) {\n          if (newIndex === realIndex) {\n            _update(true, false);\n          }\n        });\n      } // Make sure the slide is shown.\n\n\n      applyStyle(slide, {\n        display: ''\n      }); // Hold the original styles.\n\n      this.styles = getAttribute(slide, 'style') || '';\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\n      removeClass(slide, values(STATUS_CLASSES));\n      restoreStyles();\n      removeAttribute(this.container, 'style');\n    },\n\n    /**\r\n     * Update active and visible status.\r\n     */\n    update: function update() {\n      _update(this.isActive(), false);\n\n      _update(this.isVisible(), true);\n    },\n\n    /**\r\n     * Check whether this slide is active or not.\r\n     *\r\n     * @return {boolean} - True if the slide is active or false if not.\r\n     */\n    isActive: function isActive() {\n      return Splide.index === index;\n    },\n\n    /**\r\n     * Check whether this slide is visible in the viewport or not.\r\n     *\r\n     * @return {boolean} - True if the slide is visible or false if not.\r\n     */\n    isVisible: function isVisible() {\n      var active = this.isActive();\n\n      if (Splide.is(FADE) || active) {\n        return active;\n      }\n\n      var ceil = Math.ceil;\n      var trackRect = getRect(Splide.Components.Elements.track);\n      var slideRect = getRect(slide);\n\n      if (Splide.options.direction === TTB) {\n        return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);\n      }\n\n      return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);\n    },\n\n    /**\r\n     * Calculate how far this slide is from another slide and\r\n     * return true if the distance is within the given number.\r\n     *\r\n     * @param {number} from   - Index of a target slide.\r\n     * @param {number} within - True if the slide is within this number.\r\n     *\r\n     * @return {boolean} - True if the slide is within the number or false otherwise.\r\n     */\n    isWithin: function isWithin(from, within) {\n      var diff = Math.abs(from - index);\n\n      if (!Splide.is(SLIDE) && !this.isClone) {\n        diff = Math.min(diff, Splide.length - diff);\n      }\n\n      return diff < within;\n    }\n  };\n  /**\r\n   * Update classes for activity or visibility.\r\n   *\r\n   * @param {boolean} active        - Is active/visible or not.\r\n   * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n   */\n\n  function _update(active, forVisibility) {\n    var type = forVisibility ? 'visible' : 'active';\n    var className = STATUS_CLASSES[type];\n\n    if (active) {\n      addClass(slide, className);\n      Splide.emit(\"\" + type, Slide);\n    } else {\n      if (hasClass(slide, className)) {\n        removeClass(slide, className);\n        Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\n      }\n    }\n  }\n  /**\r\n   * Restore the original styles.\r\n   */\n\n\n  function restoreStyles() {\n    setAttribute(slide, 'style', Slide.styles);\n  }\n\n  return Slide;\n});\n;// CONCATENATED MODULE: ./src/js/components/elements/index.js\n/**\r\n * The component for main elements.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n/**\r\n * The property name for UID stored in a window object.\r\n *\r\n * @type {string}\r\n */\n\nvar UID_NAME = 'uid';\n/**\r\n * The component for main elements.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const components_elements = (function (Splide, Components) {\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var root = Splide.root;\n  /**\r\n   * Hold the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Store Slide objects.\r\n   *\r\n   * @type {Array}\r\n   */\n\n  var Slides = [];\n  /*\r\n   * Assign unique ID to the root element if it doesn't have the one.\r\n   * Note that IE doesn't support padStart() to fill the uid by 0.\r\n   */\n\n  if (!root.id) {\n    window.splide = window.splide || {};\n    var uid = window.splide[UID_NAME] || 0;\n    window.splide[UID_NAME] = ++uid;\n    root.id = \"splide\" + pad(uid);\n  }\n  /**\r\n   * Elements component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n\n  var Elements = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Collect main elements and store them as member properties.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      this.init();\n      Splide.on('refresh', function () {\n        _this.destroy();\n\n        _this.init();\n      }).on('updated', function () {\n        removeClass(root, getClasses());\n        addClass(root, getClasses());\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Slides.forEach(function (Slide) {\n        Slide.destroy();\n      });\n      Slides = [];\n      removeClass(root, getClasses());\n    },\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      var _this2 = this;\n\n      collect();\n      addClass(root, getClasses());\n      this.slides.forEach(function (slide, index) {\n        _this2.register(slide, index, -1);\n      });\n    },\n\n    /**\r\n     * Register a slide to create a Slide object and handle its behavior.\r\n     *\r\n     * @param {Element} slide     - A slide element.\r\n     * @param {number}  index     - A unique index. This can be negative.\r\n     * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n     */\n    register: function register(slide, index, realIndex) {\n      var SlideObject = elements_slide(Splide, index, realIndex, slide);\n      SlideObject.mount();\n      Slides.push(SlideObject);\n    },\n\n    /**\r\n     * Return the Slide object designated by the index.\r\n     * Note that \"find\" is not supported by IE.\r\n     *\r\n     * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n     */\n    getSlide: function getSlide(index) {\n      return Slides.filter(function (Slide) {\n        return Slide.index === index;\n      })[0];\n    },\n\n    /**\r\n     * Return all Slide objects.\r\n     *\r\n     * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n     *\r\n     * @return {Object[]} - Slide objects.\r\n     */\n    getSlides: function getSlides(includeClones) {\n      return includeClones ? Slides : Slides.filter(function (Slide) {\n        return !Slide.isClone;\n      });\n    },\n\n    /**\r\n     * Return Slide objects belonging to the given page.\r\n     *\r\n     * @param {number} page - A page number.\r\n     *\r\n     * @return {Object[]} - An array containing Slide objects.\r\n     */\n    getSlidesByPage: function getSlidesByPage(page) {\n      var idx = Components.Controller.toIndex(page);\n      var options = Splide.options;\n      var max = options.focus !== false ? 1 : options.perPage;\n      return Slides.filter(function (_ref) {\n        var index = _ref.index;\n        return idx <= index && index < idx + max;\n      });\n    },\n\n    /**\r\n     * Insert a slide to a slider.\r\n     * Need to refresh Splide after adding a slide.\r\n     *\r\n     * @param {Node|string} slide    - A slide element to be added.\r\n     * @param {number}      index    - A slide will be added at the position.\r\n     * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n     */\n    add: function add(slide, index, callback) {\n      if (typeof slide === 'string') {\n        slide = domify(slide);\n      }\n\n      if (slide instanceof Element) {\n        var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\n\n        applyStyle(slide, {\n          display: 'none'\n        });\n\n        if (ref) {\n          before(slide, ref);\n          this.slides.splice(index, 0, slide);\n        } else {\n          append(this.list, slide);\n          this.slides.push(slide);\n        }\n\n        loaded(slide, function () {\n          callback && callback(slide);\n        });\n      }\n    },\n\n    /**\r\n     * Remove a slide from a slider.\r\n     * Need to refresh Splide after removing a slide.\r\n     *\r\n     * @param index - Slide index.\r\n     */\n    remove: function remove(index) {\n      dom_remove(this.slides.splice(index, 1)[0]);\n    },\n\n    /**\r\n     * Trigger the provided callback for each Slide object.\r\n     *\r\n     * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n     */\n    each: function each(callback) {\n      Slides.forEach(callback);\n    },\n\n    /**\r\n     * Return slides length without clones.\r\n     *\r\n     * @return {number} - Slide length.\r\n     */\n    get length() {\n      return this.slides.length;\n    },\n\n    /**\r\n     * Return \"SlideObjects\" length including clones.\r\n     *\r\n     * @return {number} - Slide length including clones.\r\n     */\n    get total() {\n      return Slides.length;\n    }\n\n  };\n  /**\r\n   * Collect elements.\r\n   */\n\n  function collect() {\n    Elements.slider = child(root, classes.slider);\n    Elements.track = find(root, \".\" + classes.track);\n    Elements.list = child(Elements.track, classes.list);\n    exist(Elements.track && Elements.list, 'Track or list was not found.');\n    Elements.slides = children(Elements.list, classes.slide);\n    var arrows = findParts(classes.arrows);\n    Elements.arrows = {\n      prev: find(arrows, \".\" + classes.prev),\n      next: find(arrows, \".\" + classes.next)\n    };\n    var autoplay = findParts(classes.autoplay);\n    Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\n    Elements.play = find(autoplay, \".\" + classes.play);\n    Elements.pause = find(autoplay, \".\" + classes.pause);\n    Elements.track.id = Elements.track.id || root.id + \"-track\";\n    Elements.list.id = Elements.list.id || root.id + \"-list\";\n  }\n  /**\r\n   * Return class names for the root element.\r\n   */\n\n\n  function getClasses() {\n    var rootClass = classes.root;\n    var options = Splide.options;\n    return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\n  }\n  /**\r\n   * Find parts only from children of the root or track.\r\n   *\r\n   * @return {Element} - A found element or undefined.\r\n   */\n\n\n  function findParts(className) {\n    return child(root, className) || child(Elements.slider, className);\n  }\n\n  return Elements;\n});\n;// CONCATENATED MODULE: ./src/js/components/controller/index.js\n/**\r\n * The component for controlling the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\nvar floor = Math.floor;\n/**\r\n * The component for controlling the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const controller = (function (Splide, Components) {\n  /**\r\n   * Store current options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options;\n  /**\r\n   * True if the slide is LOOP mode.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoop;\n  /**\r\n   * Controller component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      options = Splide.options;\n      isLoop = Splide.is(LOOP);\n      bind();\n    },\n\n    /**\r\n     * Make track run by the given control.\r\n     * - \"+{i}\" : Increment the slide index by i.\r\n     * - \"-{i}\" : Decrement the slide index by i.\r\n     * - \"{i}\"  : Go to the slide whose index is i.\r\n     * - \">\"    : Go to next page.\r\n     * - \"<\"    : Go to prev page.\r\n     * - \">{i}\" : Go to page i.\r\n     *\r\n     * @param {string|number} control  - A control pattern.\r\n     * @param {boolean}       silently - Go to the destination without event emission.\r\n     */\n    go: function go(control, silently) {\n      var destIndex = this.trim(this.parse(control));\n      Components.Track.go(destIndex, this.rewind(destIndex), silently);\n    },\n\n    /**\r\n     * Parse the given control and return the destination index for the track.\r\n     *\r\n     * @param {string} control - A control target pattern.\r\n     *\r\n     * @return {number} - A parsed target.\r\n     */\n    parse: function parse(control) {\n      var index = Splide.index;\n      var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\n      var indicator = matches ? matches[1] : '';\n      var number = matches ? parseInt(matches[2]) : 0;\n\n      switch (indicator) {\n        case '+':\n          index += number || 1;\n          break;\n\n        case '-':\n          index -= number || 1;\n          break;\n\n        case '>':\n        case '<':\n          index = parsePage(number, index, indicator === '<');\n          break;\n\n        default:\n          index = parseInt(control);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute index from the given page number.\r\n     *\r\n     * @param {number} page - Page number.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toIndex: function toIndex(page) {\n      if (hasFocus()) {\n        return page;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage;\n      var index = page * perPage;\n      index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\n\n      if (length - perPage <= index && index < length) {\n        index = length - perPage;\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute page number from the given slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toPage: function toPage(index) {\n      if (hasFocus()) {\n        return index;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\n\n      if (length - perPage <= index && index < length) {\n        return floor((length - 1) / perPage);\n      }\n\n      return floor(index / perPage);\n    },\n\n    /**\r\n     * Trim the given index according to the current mode.\r\n     * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n     *\r\n     * @param {number} index - An index being trimmed.\r\n     *\r\n     * @return {number} - A trimmed index.\r\n     */\n    trim: function trim(index) {\n      if (!isLoop) {\n        index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Rewind the given index if it's out of range.\r\n     *\r\n     * @param {number} index - An index.\r\n     *\r\n     * @return {number} - A rewound index.\r\n     */\n    rewind: function rewind(index) {\n      var edge = this.edgeIndex;\n\n      if (isLoop) {\n        while (index > edge) {\n          index -= edge + 1;\n        }\n\n        while (index < 0) {\n          index += edge + 1;\n        }\n      } else {\n        if (index > edge) {\n          index = 0;\n        } else if (index < 0) {\n          index = edge;\n        }\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Check if the direction is \"rtl\" or not.\r\n     *\r\n     * @return {boolean} - True if \"rtl\" or false if not.\r\n     */\n    isRtl: function isRtl() {\n      return options.direction === RTL;\n    },\n\n    /**\r\n     * Return the page length.\r\n     *\r\n     * @return {number} - Max page number.\r\n     */\n    get pageLength() {\n      var length = Splide.length;\n      return hasFocus() ? length : Math.ceil(length / options.perPage);\n    },\n\n    /**\r\n     * Return the edge index.\r\n     *\r\n     * @return {number} - Edge index.\r\n     */\n    get edgeIndex() {\n      var length = Splide.length;\n\n      if (!length) {\n        return 0;\n      }\n\n      if (hasFocus() || options.isNavigation || isLoop) {\n        return length - 1;\n      }\n\n      return length - options.perPage;\n    },\n\n    /**\r\n     * Return the index of the previous slide.\r\n     *\r\n     * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n     */\n    get prevIndex() {\n      var prev = Splide.index - 1;\n\n      if (isLoop || options.rewind) {\n        prev = this.rewind(prev);\n      }\n\n      return prev > -1 ? prev : -1;\n    },\n\n    /**\r\n     * Return the index of the next slide.\r\n     *\r\n     * @return {number} - The index of the next slide if available. -1 otherwise.\r\n     */\n    get nextIndex() {\n      var next = Splide.index + 1;\n\n      if (isLoop || options.rewind) {\n        next = this.rewind(next);\n      }\n\n      return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\n    }\n\n  };\n  /**\r\n   * Listen to some events.\r\n   */\n\n  function bind() {\n    Splide.on('move', function (newIndex) {\n      Splide.index = newIndex;\n    }).on('updated refresh', function (newOptions) {\n      options = newOptions || options;\n      Splide.index = between(Splide.index, 0, Controller.edgeIndex);\n    });\n  }\n  /**\r\n   * Verify if the focus option is available or not.\r\n   *\r\n   * @return {boolean} - True if a slider has the focus option.\r\n   */\n\n\n  function hasFocus() {\n    return options.focus !== false;\n  }\n  /**\r\n   * Return the next or previous page index computed by the page number and current index.\r\n   *\r\n   * @param {number}  number - Specify the page number.\r\n   * @param {number}  index  - Current index.\r\n   * @param {boolean} prev   - Prev or next.\r\n   *\r\n   * @return {number} - Slide index.\r\n   */\n\n\n  function parsePage(number, index, prev) {\n    if (number > -1) {\n      return Controller.toIndex(number);\n    }\n\n    var perMove = options.perMove;\n    var sign = prev ? -1 : 1;\n\n    if (perMove) {\n      return index + perMove * sign;\n    }\n\n    return Controller.toIndex(Controller.toPage(index) + sign);\n  }\n\n  return Controller;\n});\n;// CONCATENATED MODULE: ./src/js/components/track/index.js\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar abs = Math.abs;\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const track = (function (Splide, Components) {\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Layout;\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements;\n  /**\r\n   * Store the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var list;\n  /**\r\n   * Whether the current direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Whether the slider type is FADE or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isFade = Splide.is(FADE);\n  /**\r\n   * Whether the slider direction is RTL or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isRTL = Splide.options.direction === RTL;\n  /**\r\n   * This will be true while transitioning from the last index to the first one.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoopPending = false;\n  /**\r\n   * Sign for the direction. Only RTL mode uses the positive sign.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var sign = isRTL ? 1 : -1;\n  /**\r\n   * Track component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Track = {\n    /**\r\n     * Make public the sign defined locally.\r\n     *\r\n     * @type {number}\r\n     */\n    sign: sign,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Elements = Components.Elements;\n      Layout = Components.Layout;\n      list = Elements.list;\n    },\n\n    /**\r\n     * Called after the component is mounted.\r\n     * The resize event must be registered after the Layout's one is done.\r\n     */\n    mounted: function mounted() {\n      var _this = this;\n\n      if (!isFade) {\n        this.jump(0);\n        Splide.on('mounted resize updated', function () {\n          _this.jump(Splide.index);\n        });\n      }\n    },\n\n    /**\r\n     * Go to the given destination index.\r\n     * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n     *\r\n     * @param {number}  destIndex - A destination index.\r\n     *                              This can be negative or greater than slides length for reaching clones.\r\n     * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n     * @param {boolean} silently  - If true, suppress emitting events.\r\n     */\n    go: function go(destIndex, newIndex, silently) {\n      var newPosition = getTrimmedPosition(destIndex);\n      var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\n\n      if (Splide.State.is(MOVING) && isLoopPending) {\n        return;\n      }\n\n      isLoopPending = destIndex !== newIndex;\n\n      if (!silently) {\n        Splide.emit('move', newIndex, prevIndex, destIndex);\n      }\n\n      if (Math.abs(newPosition - this.position) >= 1 || isFade) {\n        Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        });\n      } else {\n        if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\n          Components.Controller.go(destIndex + destIndex - prevIndex, silently);\n        } else {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        }\n      }\n    },\n\n    /**\r\n     * Move the track to the specified index.\r\n     *\r\n     * @param {number} index - A destination index where the track jumps.\r\n     */\n    jump: function jump(index) {\n      this.translate(getTrimmedPosition(index));\n    },\n\n    /**\r\n     * Set the list position by CSS translate property.\r\n     *\r\n     * @param {number} position - A new position value.\r\n     */\n    translate: function translate(position) {\n      applyStyle(list, {\n        transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\n      });\n    },\n\n    /**\r\n     * Cancel the transition and set the list position.\r\n     * Also, loop the slider if necessary.\r\n     */\n    cancel: function cancel() {\n      if (Splide.is(LOOP)) {\n        this.shift();\n      } else {\n        // Ensure the current position.\n        this.translate(this.position);\n      }\n\n      applyStyle(list, {\n        transition: ''\n      });\n    },\n\n    /**\r\n     * Shift the slider if it exceeds borders on the edge.\r\n     */\n    shift: function shift() {\n      var position = abs(this.position);\n      var left = abs(this.toPosition(0));\n      var right = abs(this.toPosition(Splide.length));\n      var innerSize = right - left;\n\n      if (position < left) {\n        position += innerSize;\n      } else if (position > right) {\n        position -= innerSize;\n      }\n\n      this.translate(sign * position);\n    },\n\n    /**\r\n     * Trim redundant spaces on the left or right edge if necessary.\r\n     *\r\n     * @param {number} position - Position value to be trimmed.\r\n     *\r\n     * @return {number} - Trimmed position.\r\n     */\n    trim: function trim(position) {\n      if (!Splide.options.trimSpace || Splide.is(LOOP)) {\n        return position;\n      }\n\n      var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\n      return between(position, edge, 0);\n    },\n\n    /**\r\n     * Calculate the closest slide index from the given position.\r\n     *\r\n     * @param {number} position - A position converted to an slide index.\r\n     *\r\n     * @return {number} - The closest slide index.\r\n     */\n    toIndex: function toIndex(position) {\n      var _this2 = this;\n\n      var index = 0;\n      var minDistance = Infinity;\n      Elements.getSlides(true).forEach(function (Slide) {\n        var slideIndex = Slide.index;\n        var distance = abs(_this2.toPosition(slideIndex) - position);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          index = slideIndex;\n        }\n      });\n      return index;\n    },\n\n    /**\r\n     * Return coordinates object by the given position.\r\n     *\r\n     * @param {number} position - A position value.\r\n     *\r\n     * @return {Object} - A coordinates object.\r\n     */\n    toCoord: function toCoord(position) {\n      return {\n        x: isVertical ? 0 : position,\n        y: isVertical ? position : 0\n      };\n    },\n\n    /**\r\n     * Calculate the track position by a slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {Object} - Calculated position.\r\n     */\n    toPosition: function toPosition(index) {\n      var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\n      return sign * (position + this.offset(index));\n    },\n\n    /**\r\n     * Return the current offset value, considering direction.\r\n     *\r\n     * @return {number} - Offset amount.\r\n     */\n    offset: function offset(index) {\n      var focus = Splide.options.focus;\n      var slideSize = Layout.slideSize(index);\n\n      if (focus === 'center') {\n        return -(Layout.size - slideSize) / 2;\n      }\n\n      return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\n    },\n\n    /**\r\n     * Return the current position.\r\n     * This returns the correct position even while transitioning by CSS.\r\n     *\r\n     * @return {number} - Current position.\r\n     */\n    get position() {\n      var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\n      return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\n    }\n\n  };\n  /**\r\n   * Called whenever slides arrive at a destination.\r\n   *\r\n   * @param {number}  destIndex - A destination index.\r\n   * @param {number}  newIndex  - A new index.\r\n   * @param {number}  prevIndex - A previous index.\r\n   * @param {boolean} silently  - If true, suppress emitting events.\r\n   */\n\n  function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\n    applyStyle(list, {\n      transition: ''\n    });\n    isLoopPending = false;\n\n    if (!isFade) {\n      Track.jump(newIndex);\n    }\n\n    if (!silently) {\n      Splide.emit('moved', newIndex, prevIndex, destIndex);\n    }\n  }\n  /**\r\n   * Convert index to the trimmed position.\r\n   *\r\n   * @return {number} - Trimmed position.\r\n   */\n\n\n  function getTrimmedPosition(index) {\n    return Track.trim(Track.toPosition(index));\n  }\n\n  return Track;\n});\n;// CONCATENATED MODULE: ./src/js/components/clones/index.js\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const clones = (function (Splide, Components) {\n  /**\r\n   * Store information of all clones.\r\n   *\r\n   * @type {Array}\r\n   */\n  var clones = [];\n  /**\r\n   * Store the current clone count on one side.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var cloneCount = 0;\n  /**\r\n   * Keep Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Clones component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Clones = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (Splide.is(LOOP)) {\n        init();\n        Splide.on('refresh:before', function () {\n          _this.destroy();\n        }).on('refresh', init).on('resize', function () {\n          if (cloneCount !== getCloneCount()) {\n            // Destroy before refresh not to collect clones by the Elements component.\n            _this.destroy();\n\n            Splide.refresh();\n          }\n        });\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      dom_remove(clones);\n      clones = [];\n    },\n\n    /**\r\n     * Return all clones.\r\n     *\r\n     * @return {Element[]} - Cloned elements.\r\n     */\n    get clones() {\n      return clones;\n    },\n\n    /**\r\n     * Return clone length.\r\n     *\r\n     * @return {number} - A length of clones.\r\n     */\n    get length() {\n      return clones.length;\n    }\n\n  };\n  /**\r\n   * Initialization.\r\n   */\n\n  function init() {\n    Clones.destroy();\n    cloneCount = getCloneCount();\n    generateClones(cloneCount);\n  }\n  /**\r\n   * Generate and append/prepend clones.\r\n   *\r\n   * @param {number} count - The half number of clones.\r\n   */\n\n\n  function generateClones(count) {\n    var length = Elements.length,\n        register = Elements.register;\n\n    if (length) {\n      var slides = Elements.slides;\n\n      while (slides.length < count) {\n        slides = slides.concat(slides);\n      } // Clones after the last element.\n\n\n      slides.slice(0, count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        append(Elements.list, clone);\n        clones.push(clone);\n        register(clone, index + length, index % length);\n      }); // Clones before the first element.\n\n      slides.slice(-count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        before(clone, slides[0]);\n        clones.push(clone);\n        register(clone, index - count, (length + index - count % length) % length);\n      });\n    }\n  }\n  /**\r\n   * Return half count of clones to be generated.\r\n   * Clone count is determined by:\r\n   * - \"clones\" value in the options.\r\n   * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n   * - Max pages a flick action can move.\r\n   * - Whether the slide length is enough for perPage.\r\n   *\r\n   * @return {number} - Count for clones.\r\n   */\n\n\n  function getCloneCount() {\n    var options = Splide.options;\n\n    if (options.clones) {\n      return options.clones;\n    } // Use the slide length in autoWidth mode because the number cannot be calculated.\n\n\n    var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\n    var dimension = options.direction === TTB ? 'Height' : 'Width';\n    var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\n\n    if (fixedSize) {\n      // Roughly calculate the count. This needs not to be strict.\n      baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\n    }\n\n    return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\n  }\n  /**\r\n   * Clone deeply the given element.\r\n   *\r\n   * @param {Element} elm - An element being duplicated.\r\n   *\r\n   * @return {Node} - A cloned node(element).\r\n   */\n\n\n  function cloneDeeply(elm) {\n    var clone = elm.cloneNode(true);\n    addClass(clone, Splide.classes.clone); // ID should not be duplicated.\n\n    removeAttribute(clone, 'id');\n    return clone;\n  }\n\n  return Clones;\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const horizontal = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options = Splide.options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\n\n    /**\r\n     * Always 0 because the height will be determined by inner contents.\r\n     *\r\n     * @type {number}\r\n     */\n    height: 0,\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var left = toPixel(root, padding.left || padding);\n      var right = toPixel(root, padding.right || padding);\n      this.padding = {\n        left: left,\n        right: right\n      };\n      applyStyle(track, {\n        paddingLeft: unit(left),\n        paddingRight: unit(right)\n      });\n    },\n\n    /**\r\n     * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n     *\r\n     * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n     */\n    totalWidth: function totalWidth(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n      var width = 0;\n\n      if (Slide) {\n        var slideRect = getRect(Slide.slide);\n        var listRect = getRect(Elements.list);\n\n        if (options.direction === RTL) {\n          width = listRect.right - slideRect.left;\n        } else {\n          width = slideRect.right - listRect.left;\n        }\n\n        width += this.gap;\n      }\n\n      return width;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth(index) {\n      if (options.autoWidth) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetWidth : 0;\n      }\n\n      var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\n      return toPixel(root, width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight() {\n      var height = options.height || options.fixedHeight || this.width * options.heightRatio;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth - this.padding.left - this.padding.right;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const vertical = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'marginBottom',\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var top = toPixel(root, padding.top || padding);\n      var bottom = toPixel(root, padding.bottom || padding);\n      this.padding = {\n        top: top,\n        bottom: bottom\n      };\n      applyStyle(track, {\n        paddingTop: unit(top),\n        paddingBottom: unit(bottom)\n      });\n    },\n\n    /**\r\n     * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n     *\r\n     * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n     */\n    totalHeight: function totalHeight(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n\n      if (Slide) {\n        return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth() {\n      return toPixel(root, options.fixedWidth || this.width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight(index) {\n      if (options.autoHeight) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetHeight : 0;\n      }\n\n      var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth;\n    },\n\n    /**\r\n     * Return slide height without padding.\r\n     *\r\n     * @return {number} - Slider height.\r\n     */\n    get height() {\n      var height = options.height || this.width * options.heightRatio;\n      exist(height, '\"height\" or \"heightRatio\" is missing.');\n      return toPixel(root, height) - this.padding.top - this.padding.bottom;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/time.js\n/**\r\n * A package of utility functions related with time.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Simple throttle function that controls how often the given function is executed.\r\n *\r\n * @param {function} func - A function to be throttled.\r\n * @param {number}   wait - Time in millisecond for interval of execution.\r\n *\r\n * @return {Function} - A debounced function.\r\n */\nfunction throttle(func, wait) {\n  var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\n\n  return function () {\n    if (!timeout) {\n      timeout = setTimeout(function () {\n        func();\n        timeout = null;\n      }, wait);\n    }\n  };\n}\n/**\r\n * Custom setInterval function that provides progress rate as callback.\r\n *\r\n * @param {function} callback - A callback function fired every time the interval time passes.\r\n * @param {number}   interval - Interval duration in milliseconds.\r\n * @param {function} progress - A callback function fired whenever the progress goes.\r\n *\r\n * @return {Object} - An object containing play() and pause() functions.\r\n */\n\nfunction createInterval(callback, interval, progress) {\n  var _window = window,\n      requestAnimationFrame = _window.requestAnimationFrame;\n  var start,\n      elapse,\n      rate,\n      _pause = true;\n\n  var step = function step(timestamp) {\n    if (!_pause) {\n      if (!start) {\n        start = timestamp;\n\n        if (rate && rate < 1) {\n          start -= rate * interval;\n        }\n      }\n\n      elapse = timestamp - start;\n      rate = elapse / interval;\n\n      if (elapse >= interval) {\n        start = 0;\n        rate = 1;\n        callback();\n      }\n\n      if (progress) {\n        progress(rate);\n      }\n\n      requestAnimationFrame(step);\n    }\n  };\n\n  return {\n    pause: function pause() {\n      _pause = true;\n      start = 0;\n    },\n    play: function play(reset) {\n      start = 0;\n\n      if (reset) {\n        rate = 0;\n      }\n\n      if (_pause) {\n        _pause = false;\n        requestAnimationFrame(step);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/js/components/layout/index.js\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const layout = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Whether the slider is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Layout = object_assign({\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      bind();\n      init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\n\n      this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\n      this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\n    },\n\n    /**\r\n     * Destroy the component.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([Elements.list, Elements.track], 'style');\n    },\n\n    /**\r\n     * Return the slider height on the vertical mode or width on the horizontal mode.\r\n     *\r\n     * @return {number}\r\n     */\n    get size() {\n      return isVertical ? this.height : this.width;\n    }\n\n  }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\n  /**\r\n   * Init slider styles according to options.\r\n   */\n\n  function init() {\n    Layout.init();\n    applyStyle(Splide.root, {\n      maxWidth: unit(Splide.options.width)\n    });\n    Elements.each(function (Slide) {\n      Slide.slide.style[Layout.margin] = unit(Layout.gap);\n    });\n    resize();\n  }\n  /**\r\n   * Listen the resize native event with throttle.\r\n   * Initialize when the component is mounted or options are updated.\r\n   */\n\n\n  function bind() {\n    Splide.on('resize load', throttle(function () {\n      Splide.emit('resize');\n    }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\n  }\n  /**\r\n   * Resize the track and slide elements.\r\n   */\n\n\n  function resize() {\n    var options = Splide.options;\n    Layout.resize();\n    applyStyle(Elements.track, {\n      height: unit(Layout.height)\n    });\n    var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\n    Elements.each(function (Slide) {\n      applyStyle(Slide.container, {\n        height: slideHeight\n      });\n      applyStyle(Slide.slide, {\n        width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\n        height: Slide.container ? null : slideHeight\n      });\n    });\n    Splide.emit('resized');\n  }\n\n  return Layout;\n});\n;// CONCATENATED MODULE: ./src/js/components/drag/index.js\n/**\r\n * The component for supporting mouse drag and swipe.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar drag_abs = Math.abs;\n/**\r\n * If the absolute velocity is greater thant this value,\r\n * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n */\n\nvar MIN_VELOCITY = 0.1;\n/**\r\n * Adjust how much the track can be pulled on the first or last page.\r\n * The larger number this is, the farther the track moves.\r\n * This should be around 5 - 9.\r\n *\r\n * @type {number}\r\n */\n\nvar FRICTION_REDUCER = 7;\n/**\r\n * The component supporting mouse drag and swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const drag = (function (Splide, Components) {\n  /**\r\n   * Store the Move component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Track = Components.Track;\n  /**\r\n   * Store the Controller component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = Components.Controller;\n  /**\r\n   * Coordinate of the track on starting drag.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var startCoord;\n  /**\r\n   * Analyzed info on starting drag.\r\n   *\r\n   * @type {Object|null}\r\n   */\n\n  var startInfo;\n  /**\r\n   * Analyzed info being updated while dragging/swiping.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var currentInfo;\n  /**\r\n   * Determine whether slides are being dragged or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isDragging;\n  /**\r\n   * Whether the slider direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Axis for the direction.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var axis = isVertical ? 'y' : 'x';\n  /**\r\n   * Drag component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Drag = {\n    /**\r\n     * Whether dragging is disabled or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    disabled: false,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      var Elements = Components.Elements;\n      var track = Elements.track;\n      Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\n        passive: false\n      }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\n        // Prevent dragging an image or anchor itself.\n        each(Elements.list.querySelectorAll('img, a'), function (elm) {\n          Splide.off('dragstart', elm).on('dragstart', function (e) {\n            e.preventDefault();\n          }, elm, {\n            passive: false\n          });\n        });\n      }).on('mounted updated', function () {\n        _this.disabled = !Splide.options.drag;\n      });\n    }\n  };\n  /**\r\n   * Called when the track starts to be dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n  function start(e) {\n    if (!Drag.disabled && !isDragging) {\n      // These prams are used to evaluate whether the slider should start moving.\n      init(e);\n    }\n  }\n  /**\r\n   * Initialize parameters.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function init(e) {\n    startCoord = Track.toCoord(Track.position);\n    startInfo = analyze(e, {});\n    currentInfo = startInfo;\n  }\n  /**\r\n   * Called while the track being dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function move(e) {\n    if (startInfo) {\n      currentInfo = analyze(e, startInfo);\n\n      if (isDragging) {\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n\n        if (!Splide.is(FADE)) {\n          var position = startCoord[axis] + currentInfo.offset[axis];\n          Track.translate(resist(position));\n        }\n      } else {\n        if (shouldMove(currentInfo)) {\n          Splide.emit('drag', startInfo);\n          isDragging = true;\n          Track.cancel(); // These params are actual drag data.\n\n          init(e);\n        }\n      }\n    }\n  }\n  /**\r\n   * Determine whether to start moving the track or not by drag angle.\r\n   *\r\n   * @param {Object} info - An information object.\r\n   *\r\n   * @return {boolean} - True if the track should be moved or false if not.\r\n   */\n\n\n  function shouldMove(_ref) {\n    var offset = _ref.offset;\n\n    if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {\n      return false;\n    }\n\n    var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\n\n    if (isVertical) {\n      angle = 90 - angle;\n    }\n\n    return angle < Splide.options.dragAngleThreshold;\n  }\n  /**\r\n   * Resist dragging the track on the first/last page because there is no more.\r\n   *\r\n   * @param {number} position - A position being applied to the track.\r\n   *\r\n   * @return {Object} - Adjusted position.\r\n   */\n\n\n  function resist(position) {\n    if (Splide.is(SLIDE)) {\n      var sign = Track.sign;\n\n      var _start = sign * Track.trim(Track.toPosition(0));\n\n      var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\n\n      position *= sign;\n\n      if (position < _start) {\n        position = _start - FRICTION_REDUCER * Math.log(_start - position);\n      } else if (position > _end) {\n        position = _end + FRICTION_REDUCER * Math.log(position - _end);\n      }\n\n      position *= sign;\n    }\n\n    return position;\n  }\n  /**\r\n   * Called when dragging ends.\r\n   */\n\n\n  function end() {\n    startInfo = null;\n\n    if (isDragging) {\n      Splide.emit('dragged', currentInfo);\n      go(currentInfo);\n      isDragging = false;\n    }\n  }\n  /**\r\n   * Go to the slide determined by the analyzed data.\r\n   *\r\n   * @param {Object} info - An info object.\r\n   */\n\n\n  function go(info) {\n    var velocity = info.velocity[axis];\n    var absV = drag_abs(velocity);\n\n    if (absV > 0) {\n      var options = Splide.options;\n      var index = Splide.index;\n      var sign = velocity < 0 ? -1 : 1;\n      var destIndex = index;\n\n      if (!Splide.is(FADE)) {\n        var destination = Track.position;\n\n        if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\n          destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\n        }\n\n        destIndex = Track.toIndex(destination);\n      }\n      /*\r\n       * Do not allow the track to go to a previous position if there is enough velocity.\r\n       * Always use the adjacent index for the fade mode.\r\n       */\n\n\n      if (destIndex === index && absV > MIN_VELOCITY) {\n        destIndex = index + sign * Track.sign;\n      }\n\n      if (Splide.is(SLIDE)) {\n        destIndex = between(destIndex, 0, Controller.edgeIndex);\n      }\n\n      Controller.go(destIndex, options.isNavigation);\n    }\n  }\n  /**\r\n   * Analyze the given event object and return important information for handling swipe behavior.\r\n   *\r\n   * @param {Event}   e          - Touch or Mouse event object.\r\n   * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n   *\r\n   * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n   */\n\n\n  function analyze(e, startInfo) {\n    var timeStamp = e.timeStamp,\n        touches = e.touches;\n\n    var _ref2 = touches ? touches[0] : e,\n        clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n\n    var _ref3 = startInfo.to || {},\n        _ref3$x = _ref3.x,\n        fromX = _ref3$x === void 0 ? clientX : _ref3$x,\n        _ref3$y = _ref3.y,\n        fromY = _ref3$y === void 0 ? clientY : _ref3$y;\n\n    var startTime = startInfo.time || 0;\n    var offset = {\n      x: clientX - fromX,\n      y: clientY - fromY\n    };\n    var duration = timeStamp - startTime;\n    var velocity = {\n      x: offset.x / duration,\n      y: offset.y / duration\n    };\n    return {\n      to: {\n        x: clientX,\n        y: clientY\n      },\n      offset: offset,\n      time: timeStamp,\n      velocity: velocity\n    };\n  }\n\n  return Drag;\n});\n;// CONCATENATED MODULE: ./src/js/components/click/index.js\n/**\r\n * The component for handling a click event.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for handling a click event.\r\n * Click should be disabled during drag/swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n/* harmony default export */ const click = (function (Splide, Components) {\n  /**\r\n   * Whether click is disabled or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var disabled = false;\n  /**\r\n   * Click component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Click = {\n    /**\r\n     * Mount only when the drag is activated and the slide type is not \"fade\".\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.drag,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('click', onClick, Components.Elements.track, {\n        capture: true\n      }).on('drag', function () {\n        disabled = true;\n      }).on('dragged', function () {\n        // Make sure the flag is released after the click event is fired.\n        setTimeout(function () {\n          disabled = false;\n        });\n      });\n    }\n  };\n  /**\r\n   * Called when a track element is clicked.\r\n   *\r\n   * @param {Event} e - A click event.\r\n   */\n\n  function onClick(e) {\n    if (disabled) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  return Click;\n});\n;// CONCATENATED MODULE: ./src/js/components/autoplay/index.js\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Set of pause flags.\r\n */\n\nvar PAUSE_FLAGS = {\n  HOVER: 1,\n  FOCUS: 2,\n  MANUAL: 3\n};\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const autoplay = (function (Splide, Components, name) {\n  /**\r\n   * Store pause flags.\r\n   *\r\n   * @type {Array}\r\n   */\n  var flags = [];\n  /**\r\n   * Store an interval object.\r\n   *\r\n   * @type {Object};\r\n   */\n\n  var interval;\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Autoplay component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Autoplay = {\n    /**\r\n     * Required only when the autoplay option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.autoplay,\n\n    /**\r\n     * Called when the component is mounted.\r\n     * Note that autoplay starts only if there are slides over perPage number.\r\n     */\n    mount: function mount() {\n      var options = Splide.options;\n\n      if (Elements.slides.length > options.perPage) {\n        interval = createInterval(function () {\n          Splide.go('>');\n        }, options.interval, function (rate) {\n          Splide.emit(name + \":playing\", rate);\n\n          if (Elements.bar) {\n            applyStyle(Elements.bar, {\n              width: rate * 100 + \"%\"\n            });\n          }\n        });\n        bind();\n        this.play();\n      }\n    },\n\n    /**\r\n     * Start autoplay.\r\n     *\r\n     * @param {number} flag - A pause flag to be removed.\r\n     */\n    play: function play(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      flags = flags.filter(function (f) {\n        return f !== flag;\n      });\n\n      if (!flags.length) {\n        Splide.emit(name + \":play\");\n        interval.play(Splide.options.resetProgress);\n      }\n    },\n\n    /**\r\n     * Pause autoplay.\r\n     * Note that Array.includes is not supported by IE.\r\n     *\r\n     * @param {number} flag - A pause flag to be added.\r\n     */\n    pause: function pause(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      interval.pause();\n\n      if (flags.indexOf(flag) === -1) {\n        flags.push(flag);\n      }\n\n      if (flags.length === 1) {\n        Splide.emit(name + \":pause\");\n      }\n    }\n  };\n  /**\r\n   * Listen some events.\r\n   */\n\n  function bind() {\n    var options = Splide.options;\n    var sibling = Splide.sibling;\n    var elms = [Splide.root, sibling ? sibling.root : null];\n\n    if (options.pauseOnHover) {\n      switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\n      switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\n    }\n\n    if (options.pauseOnFocus) {\n      switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\n      switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\n    }\n\n    if (Elements.play) {\n      Splide.on('click', function () {\n        // Need to be removed a focus flag at first.\n        Autoplay.play(PAUSE_FLAGS.FOCUS);\n        Autoplay.play(PAUSE_FLAGS.MANUAL);\n      }, Elements.play);\n    }\n\n    if (Elements.pause) {\n      switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\n    }\n\n    Splide.on('move refresh', function () {\n      Autoplay.play();\n    }) // Rewind the timer.\n    .on('destroy', function () {\n      Autoplay.pause();\n    });\n  }\n  /**\r\n   * Play or pause on the given event.\r\n   *\r\n   * @param {Element[]} elms  - Elements.\r\n   * @param {string}    event - An event name or names.\r\n   * @param {number}    flag  - A pause flag defined on the top.\r\n   * @param {boolean}   play  - Determine whether to play or pause.\r\n   */\n\n\n  function switchOn(elms, event, flag, play) {\n    elms.forEach(function (elm) {\n      Splide.on(event, function () {\n        Autoplay[play ? 'play' : 'pause'](flag);\n      }, elm);\n    });\n  }\n\n  return Autoplay;\n});\n;// CONCATENATED MODULE: ./src/js/components/cover/index.js\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const cover = (function (Splide, Components) {\n  /**\r\n   * Hold options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options = Splide.options;\n  /**\r\n   * Cover component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Cover = {\n    /**\r\n     * Required only when \"cover\" option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.cover,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('lazyload:loaded', function (img) {\n        cover(img, false);\n      });\n      Splide.on('mounted updated refresh', function () {\n        return apply(false);\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      apply(true);\n    }\n  };\n  /**\r\n   * Apply \"cover\" to all slides.\r\n   *\r\n   * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n   */\n\n  function apply(uncover) {\n    Components.Elements.each(function (Slide) {\n      var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\n\n      if (img && img.src) {\n        cover(img, uncover);\n      }\n    });\n  }\n  /**\r\n   * Set background image of the parent element, using source of the given image element.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {boolean} uncover - Reset \"cover\".\r\n   */\n\n\n  function cover(img, uncover) {\n    applyStyle(img.parentElement, {\n      background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\n    });\n    applyStyle(img, {\n      display: uncover ? '' : 'none'\n    });\n  }\n\n  return Cover;\n});\n;// CONCATENATED MODULE: ./src/js/components/arrows/path.js\n/**\r\n * Export vector path for an arrow.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Namespace definition for SVG element.\r\n *\r\n * @type {string}\r\n */\nvar XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n/**\r\n * The arrow vector path.\r\n *\r\n * @type {number}\r\n */\n\nvar PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n/**\r\n * SVG width and height.\r\n *\r\n * @type {number}\r\n */\n\nvar SIZE = 40;\n;// CONCATENATED MODULE: ./src/js/components/arrows/index.js\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const arrows = (function (Splide, Components, name) {\n  /**\r\n   * Previous arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n  var prev;\n  /**\r\n   * Next arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n\n  var next;\n  /**\r\n   * Store the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Whether arrows are created programmatically or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var created;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Arrows component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Arrows = {\n    /**\r\n     * Required when the arrows option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.arrows,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      // Attempt to get arrows from HTML source.\n      prev = Elements.arrows.prev;\n      next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\n\n      if ((!prev || !next) && Splide.options.arrows) {\n        prev = createArrow(true);\n        next = createArrow(false);\n        created = true;\n        appendArrows();\n      }\n\n      if (prev && next) {\n        bind();\n      }\n\n      this.arrows = {\n        prev: prev,\n        next: next\n      };\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      Splide.emit(name + \":mounted\", prev, next);\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([prev, next], 'disabled');\n\n      if (created) {\n        dom_remove(prev.parentElement);\n      }\n    }\n  };\n  /**\r\n   * Listen to native and custom events.\r\n   */\n\n  function bind() {\n    Splide.on('click', function () {\n      Splide.go('<');\n    }, prev).on('click', function () {\n      Splide.go('>');\n    }, next).on('mounted move updated refresh', updateDisabled);\n  }\n  /**\r\n   * Update a disabled attribute.\r\n   */\n\n\n  function updateDisabled() {\n    var _Components$Controlle = Components.Controller,\n        prevIndex = _Components$Controlle.prevIndex,\n        nextIndex = _Components$Controlle.nextIndex;\n    var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\n    prev.disabled = prevIndex < 0 || !isEnough;\n    next.disabled = nextIndex < 0 || !isEnough;\n    Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\n  }\n  /**\r\n   * Create a wrapper element and append arrows.\r\n   */\n\n\n  function appendArrows() {\n    var wrapper = create('div', {\n      \"class\": classes.arrows\n    });\n    append(wrapper, prev);\n    append(wrapper, next);\n    var slider = Elements.slider;\n    var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\n    before(wrapper, parent.firstElementChild);\n  }\n  /**\r\n   * Create an arrow element.\r\n   *\r\n   * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n   *\r\n   * @return {Element} - A created arrow element.\r\n   */\n\n\n  function createArrow(prev) {\n    var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\n    return domify(arrow);\n  }\n\n  return Arrows;\n});\n;// CONCATENATED MODULE: ./src/js/components/pagination/index.js\n/**\r\n * The component for handling pagination\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for updating some attributes of pagination nodes.\r\n *\r\n * @type {string}\r\n */\n\nvar ATTRIBUTES_UPDATE_EVENT = 'move.page';\n/**\r\n * The event name for recreating pagination.\r\n *\r\n * @type {string}\r\n */\n\nvar UPDATE_EVENT = 'updated.page refresh.page';\n/**\r\n * The component for handling pagination\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const pagination = (function (Splide, Components, name) {\n  /**\r\n   * Store all data for pagination.\r\n   * - list: A list element.\r\n   * - items: An array that contains objects(li, button, index, page).\r\n   *\r\n   * @type {Object}\r\n   */\n  var data = {};\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Pagination component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Pagination = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var pagination = Splide.options.pagination;\n\n      if (pagination) {\n        data = createPagination();\n        var slider = Elements.slider;\n        var parent = pagination === 'slider' && slider ? slider : Splide.root;\n        append(parent, data.list);\n        Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\n      }\n\n      Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\n        Pagination.destroy();\n\n        if (Splide.options.pagination) {\n          Pagination.mount();\n          Pagination.mounted();\n        }\n      });\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (Splide.options.pagination) {\n        var index = Splide.index;\n        Splide.emit(name + \":mounted\", data, this.getItem(index));\n        updateAttributes(index, -1);\n      }\n    },\n\n    /**\r\n     * Destroy the pagination.\r\n     * Be aware that node.remove() is not supported by IE.\r\n     */\n    destroy: function destroy() {\n      dom_remove(data.list);\n\n      if (data.items) {\n        data.items.forEach(function (item) {\n          Splide.off('click', item.button);\n        });\n      } // Do not remove UPDATE_EVENT to recreate pagination if needed.\n\n\n      Splide.off(ATTRIBUTES_UPDATE_EVENT);\n      data = {};\n    },\n\n    /**\r\n     * Return an item by index.\r\n     *\r\n     * @param {number} index - A slide index.\r\n     *\r\n     * @return {Object|undefined} - An item object on success or undefined on failure.\r\n     */\n    getItem: function getItem(index) {\n      return data.items[Components.Controller.toPage(index)];\n    },\n\n    /**\r\n     * Return object containing pagination data.\r\n     *\r\n     * @return {Object} - Pagination data including list and items.\r\n     */\n    get data() {\n      return data;\n    }\n\n  };\n  /**\r\n   * Update attributes.\r\n   *\r\n   * @param {number} index     - Active index.\r\n   * @param {number} prevIndex - Prev index.\r\n   */\n\n  function updateAttributes(index, prevIndex) {\n    var prev = Pagination.getItem(prevIndex);\n    var curr = Pagination.getItem(index);\n    var active = STATUS_CLASSES.active;\n\n    if (prev) {\n      removeClass(prev.button, active);\n    }\n\n    if (curr) {\n      addClass(curr.button, active);\n    }\n\n    Splide.emit(name + \":updated\", data, prev, curr);\n  }\n  /**\r\n   * Create a wrapper and button elements.\r\n   *\r\n   * @return {Object} - An object contains all data.\r\n   */\n\n\n  function createPagination() {\n    var options = Splide.options;\n    var classes = Splide.classes;\n    var list = create('ul', {\n      \"class\": classes.pagination\n    });\n    var items = Elements.getSlides(false).filter(function (Slide) {\n      return options.focus !== false || Slide.index % options.perPage === 0;\n    }).map(function (Slide, page) {\n      var li = create('li', {});\n      var button = create('button', {\n        \"class\": classes.page,\n        type: 'button'\n      });\n      append(li, button);\n      append(list, li);\n      Splide.on('click', function () {\n        Splide.go(\">\" + page);\n      }, button);\n      return {\n        li: li,\n        button: button,\n        page: page,\n        Slides: Elements.getSlidesByPage(page)\n      };\n    });\n    return {\n      list: list,\n      items: items\n    };\n  }\n\n  return Pagination;\n});\n;// CONCATENATED MODULE: ./src/js/components/lazyload/index.js\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The name for a data attribute of src.\r\n *\r\n * @type {string}\r\n */\n\nvar SRC_DATA_NAME = 'data-splide-lazy';\n/**\r\n * The name for a data attribute of srcset.\r\n *\r\n * @type {string}\r\n */\n\nvar SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const lazyload = (function (Splide, Components, name) {\n  /**\r\n   * Next index for sequential loading.\r\n   *\r\n   * @type {number}\r\n   */\n  var nextIndex;\n  /**\r\n   * Store objects containing an img element and a Slide object.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var images;\n  /**\r\n   * Store the options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var options = Splide.options;\n  /**\r\n   * Whether to load images sequentially or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isSequential = options.lazyLoad === 'sequential';\n  /**\r\n   * Lazyload component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Lazyload = {\n    /**\r\n     * Mount only when the lazyload option is provided.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.lazyLoad,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted refresh', function () {\n        init();\n        Components.Elements.each(function (Slide) {\n          each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\n            if (!img.src && !img.srcset) {\n              images.push({\n                img: img,\n                Slide: Slide\n              });\n              applyStyle(img, {\n                display: 'none'\n              });\n            }\n          });\n        });\n\n        if (isSequential) {\n          loadNext();\n        }\n      });\n\n      if (!isSequential) {\n        Splide.on(\"mounted refresh moved.\" + name, check);\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: init\n  };\n  /**\r\n   * Initialize parameters.\r\n   */\n\n  function init() {\n    images = [];\n    nextIndex = 0;\n  }\n  /**\r\n   * Check how close each image is from the active slide and\r\n   * determine whether to start loading or not, according to the distance.\r\n   *\r\n   * @param {number} index - Current index.\r\n   */\n\n\n  function check(index) {\n    index = isNaN(index) ? Splide.index : index;\n    images = images.filter(function (image) {\n      if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\n        load(image.img, image.Slide);\n        return false;\n      }\n\n      return true;\n    }); // Unbind if all images are loaded.\n\n    if (!images[0]) {\n      Splide.off(\"moved.\" + name);\n    }\n  }\n  /**\r\n   * Start loading an image.\r\n   * Creating a clone of the image element since setting src attribute directly to it\r\n   * often occurs 'hitch', blocking some other processes of a browser.\r\n   *\r\n   * @param {Element} img   - An image element.\r\n   * @param {Object}  Slide - A Slide object.\r\n   */\n\n\n  function load(img, Slide) {\n    addClass(Slide.slide, STATUS_CLASSES.loading);\n    var spinner = create('span', {\n      \"class\": Splide.classes.spinner\n    });\n    append(img.parentElement, spinner);\n\n    img.onload = function () {\n      loaded(img, spinner, Slide, false);\n    };\n\n    img.onerror = function () {\n      loaded(img, spinner, Slide, true);\n    };\n\n    setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\n    setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\n  }\n  /**\r\n   * Start loading a next image in images array.\r\n   */\n\n\n  function loadNext() {\n    if (nextIndex < images.length) {\n      var image = images[nextIndex];\n      load(image.img, image.Slide);\n    }\n\n    nextIndex++;\n  }\n  /**\r\n   * Called just after the image was loaded or loading was aborted by some error.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {Element} spinner - A spinner element.\r\n   * @param {Object}  Slide   - A Slide object.\r\n   * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n   */\n\n\n  function loaded(img, spinner, Slide, error) {\n    removeClass(Slide.slide, STATUS_CLASSES.loading);\n\n    if (!error) {\n      dom_remove(spinner);\n      applyStyle(img, {\n        display: ''\n      });\n      Splide.emit(name + \":loaded\", img).emit('resize');\n    }\n\n    if (isSequential) {\n      loadNext();\n    }\n  }\n\n  return Lazyload;\n});\n;// CONCATENATED MODULE: ./src/js/constants/a11y.js\n/**\r\n * Export aria attribute names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Attribute name for aria-current.\r\n *\r\n * @type {string}\r\n */\nvar ARIA_CURRENRT = 'aria-current';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_CONTROLS = 'aria-controls';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABEL = 'aria-label';\n/**\r\n * Attribute name for aria-labelledby.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABELLEDBY = 'aria-labelledby';\n/**\r\n * Attribute name for aria-hidden.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_HIDDEN = 'aria-hidden';\n/**\r\n * Attribute name for tab-index.\r\n *\r\n * @type {string}\r\n */\n\nvar TAB_INDEX = 'tabindex';\n;// CONCATENATED MODULE: ./src/js/components/keyboard/index.js\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Map a key to a slide control.\r\n *\r\n * @type {Object}\r\n */\n\nvar KEY_MAP = {\n  ltr: {\n    ArrowLeft: '<',\n    ArrowRight: '>',\n    // For IE.\n    Left: '<',\n    Right: '>'\n  },\n  rtl: {\n    ArrowLeft: '>',\n    ArrowRight: '<',\n    // For IE.\n    Left: '>',\n    Right: '<'\n  },\n  ttb: {\n    ArrowUp: '<',\n    ArrowDown: '>',\n    // For IE.\n    Up: '<',\n    Down: '>'\n  }\n};\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const keyboard = (function (Splide) {\n  /**\r\n   * Hold the target element.\r\n   *\r\n   * @type {Element|Document|undefined}\r\n   */\n  var target;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted updated', function () {\n        var options = Splide.options;\n        var root = Splide.root;\n        var map = KEY_MAP[options.direction];\n        var keyboard = options.keyboard;\n\n        if (target) {\n          Splide.off('keydown', target);\n          removeAttribute(root, TAB_INDEX);\n        }\n\n        if (keyboard) {\n          if (keyboard === 'focused') {\n            target = root;\n            setAttribute(root, TAB_INDEX, 0);\n          } else {\n            target = document;\n          }\n\n          Splide.on('keydown', function (e) {\n            if (map[e.key]) {\n              Splide.go(map[e.key]);\n            }\n          }, target);\n        }\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/a11y/index.js\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const a11y = (function (Splide, Components) {\n  /**\r\n   * Hold a i18n object.\r\n   *\r\n   * @type {Object}\r\n   */\n  var i18n = Splide.i18n;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * All attributes related with A11y.\r\n   *\r\n   * @type {string[]}\r\n   */\n\n  var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\n  /**\r\n   * A11y component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var A11y = {\n    /**\r\n     * Required only when the accessibility option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.accessibility,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('visible', function (Slide) {\n        updateSlide(Slide.slide, true);\n      }).on('hidden', function (Slide) {\n        updateSlide(Slide.slide, false);\n      }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\n        removeAttribute(Components.Clones.clones, allAttributes);\n      });\n\n      if (Splide.options.isNavigation) {\n        Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function (Slide) {\n          updateNavigation(Slide, true);\n        }).on('inactive', function (Slide) {\n          updateNavigation(Slide, false);\n        });\n      }\n\n      initAutoplay();\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      var Arrows = Components.Arrows;\n      var arrows = Arrows ? Arrows.arrows : {};\n      removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\n    }\n  };\n  /**\r\n   * Update slide attributes when it gets visible or hidden.\r\n   *\r\n   * @param {Element} slide   - A slide element.\r\n   * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n   */\n\n  function updateSlide(slide, visible) {\n    setAttribute(slide, ARIA_HIDDEN, !visible);\n\n    if (Splide.options.slideFocus) {\n      setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\n    }\n  }\n  /**\r\n   * Initialize arrows if they are available.\r\n   * Append screen reader elements and add aria-controls attribute.\r\n   *\r\n   * @param {Element} prev - Previous arrow element.\r\n   * @param {Element} next - Next arrow element.\r\n   */\n\n\n  function initArrows(prev, next) {\n    var controls = Elements.track.id;\n    setAttribute(prev, ARIA_CONTROLS, controls);\n    setAttribute(next, ARIA_CONTROLS, controls);\n  }\n  /**\r\n   * Update arrow attributes.\r\n   *\r\n   * @param {Element} prev      - Previous arrow element.\r\n   * @param {Element} next      - Next arrow element.\r\n   * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n   * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n   */\n\n\n  function updateArrows(prev, next, prevIndex, nextIndex) {\n    var index = Splide.index;\n    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n  }\n  /**\r\n   * Initialize pagination if it's available.\r\n   * Append a screen reader element and add aria-controls/label attribute to each item.\r\n   *\r\n   * @param {Object} data       - Data object containing all items.\r\n   * @param {Object} activeItem - An initial active item.\r\n   */\n\n\n  function initPagination(data, activeItem) {\n    if (activeItem) {\n      setAttribute(activeItem.button, ARIA_CURRENRT, true);\n    }\n\n    data.items.forEach(function (item) {\n      var options = Splide.options;\n      var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\n      var label = sprintf(text, item.page + 1);\n      var button = item.button;\n      var controls = item.Slides.map(function (Slide) {\n        return Slide.slide.id;\n      });\n      setAttribute(button, ARIA_CONTROLS, controls.join(' '));\n      setAttribute(button, ARIA_LABEL, label);\n    });\n  }\n  /**\r\n   * Update pagination attributes.\r\n   *\r\n   * @param {Object}  data - Data object containing all items.\r\n   * @param {Element} prev - A previous active element.\r\n   * @param {Element} curr - A current active element.\r\n   */\n\n\n  function updatePagination(data, prev, curr) {\n    if (prev) {\n      removeAttribute(prev.button, ARIA_CURRENRT);\n    }\n\n    if (curr) {\n      setAttribute(curr.button, ARIA_CURRENRT, true);\n    }\n  }\n  /**\r\n   * Initialize autoplay buttons.\r\n   */\n\n\n  function initAutoplay() {\n    ['play', 'pause'].forEach(function (name) {\n      var elm = Elements[name];\n\n      if (elm) {\n        if (!isButton(elm)) {\n          setAttribute(elm, 'role', 'button');\n        }\n\n        setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\n        setAttribute(elm, ARIA_LABEL, i18n[name]);\n      }\n    });\n  }\n  /**\r\n   * Initialize navigation slider.\r\n   * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n   *\r\n   * @param {Splide} main - A main Splide instance.\r\n   */\n\n\n  function initNavigation(main) {\n    Elements.each(function (Slide) {\n      var slide = Slide.slide;\n      var realIndex = Slide.realIndex;\n\n      if (!isButton(slide)) {\n        setAttribute(slide, 'role', 'button');\n      }\n\n      var slideIndex = realIndex > -1 ? realIndex : Slide.index;\n      var label = sprintf(i18n.slideX, slideIndex + 1);\n      var mainSlide = main.Components.Elements.getSlide(slideIndex);\n      setAttribute(slide, ARIA_LABEL, label);\n\n      if (mainSlide) {\n        setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\n      }\n    });\n  }\n  /**\r\n   * Update navigation attributes.\r\n   *\r\n   * @param {Object}  Slide  - A target Slide object.\r\n   * @param {boolean} active - True if the slide is active or false if inactive.\r\n   */\n\n\n  function updateNavigation(_ref, active) {\n    var slide = _ref.slide;\n\n    if (active) {\n      setAttribute(slide, ARIA_CURRENRT, true);\n    } else {\n      removeAttribute(slide, ARIA_CURRENRT);\n    }\n  }\n  /**\r\n   * Check if the given element is button or not.\r\n   *\r\n   * @param {Element} elm - An element to be checked.\r\n   *\r\n   * @return {boolean} - True if the given element is button.\r\n   */\n\n\n  function isButton(elm) {\n    return elm.tagName === 'BUTTON';\n  }\n\n  return A11y;\n});\n;// CONCATENATED MODULE: ./src/js/components/sync/index.js\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for sync.\r\n *\r\n * @type {string}\r\n */\n\nvar SYNC_EVENT = 'move.sync';\n/**\r\n * The event names for click navigation.\r\n * @type {string}\r\n */\n\nvar CLICK_EVENTS = 'mouseup touchend';\n/**\r\n * The keys for triggering the navigation button.\r\n *\r\n * @type {String[]}\r\n */\n\nvar TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const sync = (function (Splide) {\n  /**\r\n   * Keep the sibling Splide instance.\r\n   *\r\n   * @type {Splide}\r\n   */\n  var sibling = Splide.sibling;\n  /**\r\n   * Whether the sibling slider is navigation or not.\r\n   *\r\n   * @type {Splide|boolean}\r\n   */\n\n  var isNavigation = sibling && sibling.options.isNavigation;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Sync = {\n    /**\r\n     * Required only when the sub slider is available.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: !!sibling,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      syncMain();\n      syncSibling();\n\n      if (isNavigation) {\n        bind();\n        Splide.on('refresh', function () {\n          setTimeout(function () {\n            bind();\n            sibling.emit('navigation:updated', Splide);\n          });\n        });\n      }\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (isNavigation) {\n        sibling.emit('navigation:mounted', Splide);\n      }\n    }\n  };\n  /**\r\n   * Listen the primary slider event to move secondary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n  function syncMain() {\n    Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\n      syncSibling();\n    });\n  }\n  /**\r\n   * Listen the secondary slider event to move primary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n\n  function syncSibling() {\n    sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\n      syncMain();\n    });\n  }\n  /**\r\n   * Listen some events on each slide.\r\n   */\n\n\n  function bind() {\n    sibling.Components.Elements.each(function (_ref) {\n      var slide = _ref.slide,\n          index = _ref.index;\n\n      /*\r\n       * Listen mouseup and touchend events to handle click.\r\n       */\n      Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function (e) {\n        // Ignore a middle or right click.\n        if (!e.button || e.button === 0) {\n          moveSibling(index);\n        }\n      }, slide);\n      /*\r\n       * Subscribe keyup to handle Enter and Space key.\r\n       * Note that Array.includes is not supported by IE.\r\n       */\n\n      Splide.off('keyup', slide).on('keyup', function (e) {\n        if (TRIGGER_KEYS.indexOf(e.key) > -1) {\n          e.preventDefault();\n          moveSibling(index);\n        }\n      }, slide, {\n        passive: false\n      });\n    });\n  }\n  /**\r\n   * Move the sibling to the given index.\r\n   * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n   *\r\n   * @param {number} index - Target index.\r\n   */\n\n\n  function moveSibling(index) {\n    if (Splide.State.is(IDLE)) {\n      sibling.go(index);\n    }\n  }\n\n  return Sync;\n});\n;// CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Interval time for throttle.\r\n *\r\n * @type {number}\r\n */\n\nvar THROTTLE = 50;\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const breakpoints = (function (Splide) {\n  /**\r\n   * Store breakpoints.\r\n   *\r\n   * @type {Object|boolean}\r\n   */\n  var breakpoints = Splide.options.breakpoints;\n  /**\r\n   * The check function whose frequency of call is reduced.\r\n   *\r\n   * @type {Function}\r\n   */\n\n  var throttledCheck = throttle(check, THROTTLE);\n  /**\r\n   * Keep initial options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var initialOptions;\n  /**\r\n   * An array containing objects of point and MediaQueryList.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var map = [];\n  /**\r\n   * Hold the previous breakpoint.\r\n   *\r\n   * @type {number|undefined}\r\n   */\n\n  var prevPoint;\n  /**\r\n   * Breakpoints component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Breakpoints = {\n    /**\r\n     * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: breakpoints && matchMedia,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      map = Object.keys(breakpoints).sort(function (n, m) {\n        return +n - +m;\n      }).map(function (point) {\n        return {\n          point: point,\n          mql: matchMedia(\"(max-width:\" + point + \"px)\")\n        };\n      });\n      /*\r\n       * To keep monitoring resize event after destruction without \"completely\",\r\n       * use native addEventListener instead of Splide.on.\r\n       */\n\n      this.destroy(true);\n      addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\n\n      initialOptions = Splide.options;\n      check();\n    },\n\n    /**\r\n     * Destroy.\r\n     *\r\n     * @param {boolean} completely - Whether to destroy Splide completely.\r\n     */\n    destroy: function destroy(completely) {\n      if (completely) {\n        removeEventListener('resize', throttledCheck);\n      }\n    }\n  };\n  /**\r\n   * Check the breakpoint.\r\n   */\n\n  function check() {\n    var point = getPoint();\n\n    if (point !== prevPoint) {\n      prevPoint = point;\n      var State = Splide.State;\n      var options = breakpoints[point] || initialOptions;\n      var destroy = options.destroy;\n\n      if (destroy) {\n        Splide.options = initialOptions;\n        Splide.destroy(destroy === 'completely');\n      } else {\n        if (State.is(DESTROYED)) {\n          Splide.mount();\n        }\n\n        Splide.options = options;\n      }\n    }\n  }\n  /**\r\n   * Return the breakpoint matching current window width.\r\n   * Note that Array.prototype.find is not supported by IE.\r\n   *\r\n   * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n   */\n\n\n  function getPoint() {\n    var item = map.filter(function (item) {\n      return item.mql.matches;\n    })[0];\n    return item ? item.point : -1;\n  }\n\n  return Breakpoints;\n});\n;// CONCATENATED MODULE: ./src/js/components/index.js\n/**\r\n * Export components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar COMPLETE = {\n  Options: options,\n  Breakpoints: breakpoints,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Autoplay: autoplay,\n  Cover: cover,\n  Arrows: arrows,\n  Pagination: pagination,\n  LazyLoad: lazyload,\n  Keyboard: keyboard,\n  Sync: sync,\n  A11y: a11y\n};\nvar LIGHT = {\n  Options: options,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Arrows: arrows,\n  Pagination: pagination,\n  A11y: a11y\n};\n;// CONCATENATED MODULE: ./build/module/module.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\r\n * Export Splide class for import.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Export Splide class for import from other projects.\r\n */\n\nvar module_Splide = /*#__PURE__*/function (_Core) {\n  _inheritsLoose(Splide, _Core);\n\n  function Splide(root, options) {\n    return _Core.call(this, root, options, COMPLETE) || this;\n  }\n\n  return Splide;\n}(Splide);\n\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_139193__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_139193__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_139193__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_139193__.o(definition, key) && !__nested_webpack_require_139193__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_139193__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_139193__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_139193__(311);\n/******/ })()\n;\n});\n\n//# sourceURL=webpack://loading-page/./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/js/splide.esm.js?");

/***/ }),

/***/ "./src/js/jquery-1.8.3.min.js":
/*!************************************!*\
  !*** ./src/js/jquery-1.8.3.min.js ***!
  \************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//素材家园独家编辑整理：www.sucaijiayuan.com\n(function (e, t) {\n  function _(e) {\n    var t = M[e] = {};\n    return v.each(e.split(y), function (e, n) {\n      t[n] = !0;\n    }), t;\n  }\n\n  function H(e, n, r) {\n    if (r === t && e.nodeType === 1) {\n      var i = \"data-\" + n.replace(P, \"-$1\").toLowerCase();\n      r = e.getAttribute(i);\n\n      if (typeof r == \"string\") {\n        try {\n          r = r === \"true\" ? !0 : r === \"false\" ? !1 : r === \"null\" ? null : +r + \"\" === r ? +r : D.test(r) ? v.parseJSON(r) : r;\n        } catch (s) {}\n\n        v.data(e, n, r);\n      } else r = t;\n    }\n\n    return r;\n  }\n\n  function B(e) {\n    var t;\n\n    for (t in e) {\n      if (t === \"data\" && v.isEmptyObject(e[t])) continue;\n      if (t !== \"toJSON\") return !1;\n    }\n\n    return !0;\n  }\n\n  function et() {\n    return !1;\n  }\n\n  function tt() {\n    return !0;\n  }\n\n  function ut(e) {\n    return !e || !e.parentNode || e.parentNode.nodeType === 11;\n  }\n\n  function at(e, t) {\n    do e = e[t]; while (e && e.nodeType !== 1);\n\n    return e;\n  }\n\n  function ft(e, t, n) {\n    t = t || 0;\n    if (v.isFunction(t)) return v.grep(e, function (e, r) {\n      var i = !!t.call(e, r, e);\n      return i === n;\n    });\n    if (t.nodeType) return v.grep(e, function (e, r) {\n      return e === t === n;\n    });\n\n    if (typeof t == \"string\") {\n      var r = v.grep(e, function (e) {\n        return e.nodeType === 1;\n      });\n      if (it.test(t)) return v.filter(t, r, !n);\n      t = v.filter(t, r);\n    }\n\n    return v.grep(e, function (e, r) {\n      return v.inArray(e, t) >= 0 === n;\n    });\n  }\n\n  function lt(e) {\n    var t = ct.split(\"|\"),\n        n = e.createDocumentFragment();\n    if (n.createElement) while (t.length) n.createElement(t.pop());\n    return n;\n  }\n\n  function Lt(e, t) {\n    return e.getElementsByTagName(t)[0] || e.appendChild(e.ownerDocument.createElement(t));\n  }\n\n  function At(e, t) {\n    if (t.nodeType !== 1 || !v.hasData(e)) return;\n\n    var n,\n        r,\n        i,\n        s = v._data(e),\n        o = v._data(t, s),\n        u = s.events;\n\n    if (u) {\n      delete o.handle, o.events = {};\n\n      for (n in u) for (r = 0, i = u[n].length; r < i; r++) v.event.add(t, n, u[n][r]);\n    }\n\n    o.data && (o.data = v.extend({}, o.data));\n  }\n\n  function Ot(e, t) {\n    var n;\n    if (t.nodeType !== 1) return;\n    t.clearAttributes && t.clearAttributes(), t.mergeAttributes && t.mergeAttributes(e), n = t.nodeName.toLowerCase(), n === \"object\" ? (t.parentNode && (t.outerHTML = e.outerHTML), v.support.html5Clone && e.innerHTML && !v.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : n === \"input\" && Et.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : n === \"option\" ? t.selected = e.defaultSelected : n === \"input\" || n === \"textarea\" ? t.defaultValue = e.defaultValue : n === \"script\" && t.text !== e.text && (t.text = e.text), t.removeAttribute(v.expando);\n  }\n\n  function Mt(e) {\n    return typeof e.getElementsByTagName != \"undefined\" ? e.getElementsByTagName(\"*\") : typeof e.querySelectorAll != \"undefined\" ? e.querySelectorAll(\"*\") : [];\n  }\n\n  function _t(e) {\n    Et.test(e.type) && (e.defaultChecked = e.checked);\n  }\n\n  function Qt(e, t) {\n    if (t in e) return t;\n    var n = t.charAt(0).toUpperCase() + t.slice(1),\n        r = t,\n        i = Jt.length;\n\n    while (i--) {\n      t = Jt[i] + n;\n      if (t in e) return t;\n    }\n\n    return r;\n  }\n\n  function Gt(e, t) {\n    return e = t || e, v.css(e, \"display\") === \"none\" || !v.contains(e.ownerDocument, e);\n  }\n\n  function Yt(e, t) {\n    var n,\n        r,\n        i = [],\n        s = 0,\n        o = e.length;\n\n    for (; s < o; s++) {\n      n = e[s];\n      if (!n.style) continue;\n      i[s] = v._data(n, \"olddisplay\"), t ? (!i[s] && n.style.display === \"none\" && (n.style.display = \"\"), n.style.display === \"\" && Gt(n) && (i[s] = v._data(n, \"olddisplay\", nn(n.nodeName)))) : (r = Dt(n, \"display\"), !i[s] && r !== \"none\" && v._data(n, \"olddisplay\", r));\n    }\n\n    for (s = 0; s < o; s++) {\n      n = e[s];\n      if (!n.style) continue;\n      if (!t || n.style.display === \"none\" || n.style.display === \"\") n.style.display = t ? i[s] || \"\" : \"none\";\n    }\n\n    return e;\n  }\n\n  function Zt(e, t, n) {\n    var r = Rt.exec(t);\n    return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || \"px\") : t;\n  }\n\n  function en(e, t, n, r) {\n    var i = n === (r ? \"border\" : \"content\") ? 4 : t === \"width\" ? 1 : 0,\n        s = 0;\n\n    for (; i < 4; i += 2) n === \"margin\" && (s += v.css(e, n + $t[i], !0)), r ? (n === \"content\" && (s -= parseFloat(Dt(e, \"padding\" + $t[i])) || 0), n !== \"margin\" && (s -= parseFloat(Dt(e, \"border\" + $t[i] + \"Width\")) || 0)) : (s += parseFloat(Dt(e, \"padding\" + $t[i])) || 0, n !== \"padding\" && (s += parseFloat(Dt(e, \"border\" + $t[i] + \"Width\")) || 0));\n\n    return s;\n  }\n\n  function tn(e, t, n) {\n    var r = t === \"width\" ? e.offsetWidth : e.offsetHeight,\n        i = !0,\n        s = v.support.boxSizing && v.css(e, \"boxSizing\") === \"border-box\";\n\n    if (r <= 0 || r == null) {\n      r = Dt(e, t);\n      if (r < 0 || r == null) r = e.style[t];\n      if (Ut.test(r)) return r;\n      i = s && (v.support.boxSizingReliable || r === e.style[t]), r = parseFloat(r) || 0;\n    }\n\n    return r + en(e, t, n || (s ? \"border\" : \"content\"), i) + \"px\";\n  }\n\n  function nn(e) {\n    if (Wt[e]) return Wt[e];\n    var t = v(\"<\" + e + \">\").appendTo(i.body),\n        n = t.css(\"display\");\n    t.remove();\n\n    if (n === \"none\" || n === \"\") {\n      Pt = i.body.appendChild(Pt || v.extend(i.createElement(\"iframe\"), {\n        frameBorder: 0,\n        width: 0,\n        height: 0\n      }));\n      if (!Ht || !Pt.createElement) Ht = (Pt.contentWindow || Pt.contentDocument).document, Ht.write(\"<!doctype html><html><body>\"), Ht.close();\n      t = Ht.body.appendChild(Ht.createElement(e)), n = Dt(t, \"display\"), i.body.removeChild(Pt);\n    }\n\n    return Wt[e] = n, n;\n  }\n\n  function fn(e, t, n, r) {\n    var i;\n    if (v.isArray(t)) v.each(t, function (t, i) {\n      n || sn.test(e) ? r(e, i) : fn(e + \"[\" + (typeof i == \"object\" ? t : \"\") + \"]\", i, n, r);\n    });else if (!n && v.type(t) === \"object\") for (i in t) fn(e + \"[\" + i + \"]\", t[i], n, r);else r(e, t);\n  }\n\n  function Cn(e) {\n    return function (t, n) {\n      typeof t != \"string\" && (n = t, t = \"*\");\n      var r,\n          i,\n          s,\n          o = t.toLowerCase().split(y),\n          u = 0,\n          a = o.length;\n      if (v.isFunction(n)) for (; u < a; u++) r = o[u], s = /^\\+/.test(r), s && (r = r.substr(1) || \"*\"), i = e[r] = e[r] || [], i[s ? \"unshift\" : \"push\"](n);\n    };\n  }\n\n  function kn(e, n, r, i, s, o) {\n    s = s || n.dataTypes[0], o = o || {}, o[s] = !0;\n    var u,\n        a = e[s],\n        f = 0,\n        l = a ? a.length : 0,\n        c = e === Sn;\n\n    for (; f < l && (c || !u); f++) u = a[f](n, r, i), typeof u == \"string\" && (!c || o[u] ? u = t : (n.dataTypes.unshift(u), u = kn(e, n, r, i, u, o)));\n\n    return (c || !u) && !o[\"*\"] && (u = kn(e, n, r, i, \"*\", o)), u;\n  }\n\n  function Ln(e, n) {\n    var r,\n        i,\n        s = v.ajaxSettings.flatOptions || {};\n\n    for (r in n) n[r] !== t && ((s[r] ? e : i || (i = {}))[r] = n[r]);\n\n    i && v.extend(!0, e, i);\n  }\n\n  function An(e, n, r) {\n    var i,\n        s,\n        o,\n        u,\n        a = e.contents,\n        f = e.dataTypes,\n        l = e.responseFields;\n\n    for (s in l) s in r && (n[l[s]] = r[s]);\n\n    while (f[0] === \"*\") f.shift(), i === t && (i = e.mimeType || n.getResponseHeader(\"content-type\"));\n\n    if (i) for (s in a) if (a[s] && a[s].test(i)) {\n      f.unshift(s);\n      break;\n    }\n    if (f[0] in r) o = f[0];else {\n      for (s in r) {\n        if (!f[0] || e.converters[s + \" \" + f[0]]) {\n          o = s;\n          break;\n        }\n\n        u || (u = s);\n      }\n\n      o = o || u;\n    }\n    if (o) return o !== f[0] && f.unshift(o), r[o];\n  }\n\n  function On(e, t) {\n    var n,\n        r,\n        i,\n        s,\n        o = e.dataTypes.slice(),\n        u = o[0],\n        a = {},\n        f = 0;\n    e.dataFilter && (t = e.dataFilter(t, e.dataType));\n    if (o[1]) for (n in e.converters) a[n.toLowerCase()] = e.converters[n];\n\n    for (; i = o[++f];) if (i !== \"*\") {\n      if (u !== \"*\" && u !== i) {\n        n = a[u + \" \" + i] || a[\"* \" + i];\n        if (!n) for (r in a) {\n          s = r.split(\" \");\n\n          if (s[1] === i) {\n            n = a[u + \" \" + s[0]] || a[\"* \" + s[0]];\n\n            if (n) {\n              n === !0 ? n = a[r] : a[r] !== !0 && (i = s[0], o.splice(f--, 0, i));\n              break;\n            }\n          }\n        }\n        if (n !== !0) if (n && e[\"throws\"]) t = n(t);else try {\n          t = n(t);\n        } catch (l) {\n          return {\n            state: \"parsererror\",\n            error: n ? l : \"No conversion from \" + u + \" to \" + i\n          };\n        }\n      }\n\n      u = i;\n    }\n\n    return {\n      state: \"success\",\n      data: t\n    };\n  }\n\n  function Fn() {\n    try {\n      return new e.XMLHttpRequest();\n    } catch (t) {}\n  }\n\n  function In() {\n    try {\n      return new e.ActiveXObject(\"Microsoft.XMLHTTP\");\n    } catch (t) {}\n  }\n\n  function $n() {\n    return setTimeout(function () {\n      qn = t;\n    }, 0), qn = v.now();\n  }\n\n  function Jn(e, t) {\n    v.each(t, function (t, n) {\n      var r = (Vn[t] || []).concat(Vn[\"*\"]),\n          i = 0,\n          s = r.length;\n\n      for (; i < s; i++) if (r[i].call(e, t, n)) return;\n    });\n  }\n\n  function Kn(e, t, n) {\n    var r,\n        i = 0,\n        s = 0,\n        o = Xn.length,\n        u = v.Deferred().always(function () {\n      delete a.elem;\n    }),\n        a = function () {\n      var t = qn || $n(),\n          n = Math.max(0, f.startTime + f.duration - t),\n          r = n / f.duration || 0,\n          i = 1 - r,\n          s = 0,\n          o = f.tweens.length;\n\n      for (; s < o; s++) f.tweens[s].run(i);\n\n      return u.notifyWith(e, [f, i, n]), i < 1 && o ? n : (u.resolveWith(e, [f]), !1);\n    },\n        f = u.promise({\n      elem: e,\n      props: v.extend({}, t),\n      opts: v.extend(!0, {\n        specialEasing: {}\n      }, n),\n      originalProperties: t,\n      originalOptions: n,\n      startTime: qn || $n(),\n      duration: n.duration,\n      tweens: [],\n      createTween: function (t, n, r) {\n        var i = v.Tween(e, f.opts, t, n, f.opts.specialEasing[t] || f.opts.easing);\n        return f.tweens.push(i), i;\n      },\n      stop: function (t) {\n        var n = 0,\n            r = t ? f.tweens.length : 0;\n\n        for (; n < r; n++) f.tweens[n].run(1);\n\n        return t ? u.resolveWith(e, [f, t]) : u.rejectWith(e, [f, t]), this;\n      }\n    }),\n        l = f.props;\n\n    Qn(l, f.opts.specialEasing);\n\n    for (; i < o; i++) {\n      r = Xn[i].call(f, e, l, f.opts);\n      if (r) return r;\n    }\n\n    return Jn(f, l), v.isFunction(f.opts.start) && f.opts.start.call(e, f), v.fx.timer(v.extend(a, {\n      anim: f,\n      queue: f.opts.queue,\n      elem: e\n    })), f.progress(f.opts.progress).done(f.opts.done, f.opts.complete).fail(f.opts.fail).always(f.opts.always);\n  }\n\n  function Qn(e, t) {\n    var n, r, i, s, o;\n\n    for (n in e) {\n      r = v.camelCase(n), i = t[r], s = e[n], v.isArray(s) && (i = s[1], s = e[n] = s[0]), n !== r && (e[r] = s, delete e[n]), o = v.cssHooks[r];\n\n      if (o && \"expand\" in o) {\n        s = o.expand(s), delete e[r];\n\n        for (n in s) n in e || (e[n] = s[n], t[n] = i);\n      } else t[r] = i;\n    }\n  }\n\n  function Gn(e, t, n) {\n    var r,\n        i,\n        s,\n        o,\n        u,\n        a,\n        f,\n        l,\n        c,\n        h = this,\n        p = e.style,\n        d = {},\n        m = [],\n        g = e.nodeType && Gt(e);\n    n.queue || (l = v._queueHooks(e, \"fx\"), l.unqueued == null && (l.unqueued = 0, c = l.empty.fire, l.empty.fire = function () {\n      l.unqueued || c();\n    }), l.unqueued++, h.always(function () {\n      h.always(function () {\n        l.unqueued--, v.queue(e, \"fx\").length || l.empty.fire();\n      });\n    })), e.nodeType === 1 && (\"height\" in t || \"width\" in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], v.css(e, \"display\") === \"inline\" && v.css(e, \"float\") === \"none\" && (!v.support.inlineBlockNeedsLayout || nn(e.nodeName) === \"inline\" ? p.display = \"inline-block\" : p.zoom = 1)), n.overflow && (p.overflow = \"hidden\", v.support.shrinkWrapBlocks || h.done(function () {\n      p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2];\n    }));\n\n    for (r in t) {\n      s = t[r];\n\n      if (Un.exec(s)) {\n        delete t[r], a = a || s === \"toggle\";\n        if (s === (g ? \"hide\" : \"show\")) continue;\n        m.push(r);\n      }\n    }\n\n    o = m.length;\n\n    if (o) {\n      u = v._data(e, \"fxshow\") || v._data(e, \"fxshow\", {}), \"hidden\" in u && (g = u.hidden), a && (u.hidden = !g), g ? v(e).show() : h.done(function () {\n        v(e).hide();\n      }), h.done(function () {\n        var t;\n        v.removeData(e, \"fxshow\", !0);\n\n        for (t in d) v.style(e, t, d[t]);\n      });\n\n      for (r = 0; r < o; r++) i = m[r], f = h.createTween(i, g ? u[i] : 0), d[i] = u[i] || v.style(e, i), i in u || (u[i] = f.start, g && (f.end = f.start, f.start = i === \"width\" || i === \"height\" ? 1 : 0));\n    }\n  }\n\n  function Yn(e, t, n, r, i) {\n    return new Yn.prototype.init(e, t, n, r, i);\n  }\n\n  function Zn(e, t) {\n    var n,\n        r = {\n      height: e\n    },\n        i = 0;\n    t = t ? 1 : 0;\n\n    for (; i < 4; i += 2 - t) n = $t[i], r[\"margin\" + n] = r[\"padding\" + n] = e;\n\n    return t && (r.opacity = r.width = e), r;\n  }\n\n  function tr(e) {\n    return v.isWindow(e) ? e : e.nodeType === 9 ? e.defaultView || e.parentWindow : !1;\n  }\n\n  var n,\n      r,\n      i = e.document,\n      s = e.location,\n      o = e.navigator,\n      u = e.jQuery,\n      a = e.$,\n      f = Array.prototype.push,\n      l = Array.prototype.slice,\n      c = Array.prototype.indexOf,\n      h = Object.prototype.toString,\n      p = Object.prototype.hasOwnProperty,\n      d = String.prototype.trim,\n      v = function (e, t) {\n    return new v.fn.init(e, t, n);\n  },\n      m = /[\\-+]?(?:\\d*\\.|)\\d+(?:[eE][\\-+]?\\d+|)/.source,\n      g = /\\S/,\n      y = /\\s+/,\n      b = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      w = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n      E = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      S = /^[\\],:{}\\s]*$/,\n      x = /(?:^|:|,)(?:\\s*\\[)+/g,\n      T = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n      N = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d\\d*\\.|)\\d+(?:[eE][\\-+]?\\d+|)/g,\n      C = /^-ms-/,\n      k = /-([\\da-z])/gi,\n      L = function (e, t) {\n    return (t + \"\").toUpperCase();\n  },\n      A = function () {\n    i.addEventListener ? (i.removeEventListener(\"DOMContentLoaded\", A, !1), v.ready()) : i.readyState === \"complete\" && (i.detachEvent(\"onreadystatechange\", A), v.ready());\n  },\n      O = {};\n\n  v.fn = v.prototype = {\n    constructor: v,\n    init: function (e, n, r) {\n      var s, o, u, a;\n      if (!e) return this;\n      if (e.nodeType) return this.context = this[0] = e, this.length = 1, this;\n\n      if (typeof e == \"string\") {\n        e.charAt(0) === \"<\" && e.charAt(e.length - 1) === \">\" && e.length >= 3 ? s = [null, e, null] : s = w.exec(e);\n\n        if (s && (s[1] || !n)) {\n          if (s[1]) return n = n instanceof v ? n[0] : n, a = n && n.nodeType ? n.ownerDocument || n : i, e = v.parseHTML(s[1], a, !0), E.test(s[1]) && v.isPlainObject(n) && this.attr.call(e, n, !0), v.merge(this, e);\n          o = i.getElementById(s[2]);\n\n          if (o && o.parentNode) {\n            if (o.id !== s[2]) return r.find(e);\n            this.length = 1, this[0] = o;\n          }\n\n          return this.context = i, this.selector = e, this;\n        }\n\n        return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);\n      }\n\n      return v.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, this.context = e.context), v.makeArray(e, this));\n    },\n    selector: \"\",\n    jquery: \"1.8.3\",\n    length: 0,\n    size: function () {\n      return this.length;\n    },\n    toArray: function () {\n      return l.call(this);\n    },\n    get: function (e) {\n      return e == null ? this.toArray() : e < 0 ? this[this.length + e] : this[e];\n    },\n    pushStack: function (e, t, n) {\n      var r = v.merge(this.constructor(), e);\n      return r.prevObject = this, r.context = this.context, t === \"find\" ? r.selector = this.selector + (this.selector ? \" \" : \"\") + n : t && (r.selector = this.selector + \".\" + t + \"(\" + n + \")\"), r;\n    },\n    each: function (e, t) {\n      return v.each(this, e, t);\n    },\n    ready: function (e) {\n      return v.ready.promise().done(e), this;\n    },\n    eq: function (e) {\n      return e = +e, e === -1 ? this.slice(e) : this.slice(e, e + 1);\n    },\n    first: function () {\n      return this.eq(0);\n    },\n    last: function () {\n      return this.eq(-1);\n    },\n    slice: function () {\n      return this.pushStack(l.apply(this, arguments), \"slice\", l.call(arguments).join(\",\"));\n    },\n    map: function (e) {\n      return this.pushStack(v.map(this, function (t, n) {\n        return e.call(t, n, t);\n      }));\n    },\n    end: function () {\n      return this.prevObject || this.constructor(null);\n    },\n    push: f,\n    sort: [].sort,\n    splice: [].splice\n  }, v.fn.init.prototype = v.fn, v.extend = v.fn.extend = function () {\n    var e,\n        n,\n        r,\n        i,\n        s,\n        o,\n        u = arguments[0] || {},\n        a = 1,\n        f = arguments.length,\n        l = !1;\n    typeof u == \"boolean\" && (l = u, u = arguments[1] || {}, a = 2), typeof u != \"object\" && !v.isFunction(u) && (u = {}), f === a && (u = this, --a);\n\n    for (; a < f; a++) if ((e = arguments[a]) != null) for (n in e) {\n      r = u[n], i = e[n];\n      if (u === i) continue;\n      l && i && (v.isPlainObject(i) || (s = v.isArray(i))) ? (s ? (s = !1, o = r && v.isArray(r) ? r : []) : o = r && v.isPlainObject(r) ? r : {}, u[n] = v.extend(l, o, i)) : i !== t && (u[n] = i);\n    }\n\n    return u;\n  }, v.extend({\n    noConflict: function (t) {\n      return e.$ === v && (e.$ = a), t && e.jQuery === v && (e.jQuery = u), v;\n    },\n    isReady: !1,\n    readyWait: 1,\n    holdReady: function (e) {\n      e ? v.readyWait++ : v.ready(!0);\n    },\n    ready: function (e) {\n      if (e === !0 ? --v.readyWait : v.isReady) return;\n      if (!i.body) return setTimeout(v.ready, 1);\n      v.isReady = !0;\n      if (e !== !0 && --v.readyWait > 0) return;\n      r.resolveWith(i, [v]), v.fn.trigger && v(i).trigger(\"ready\").off(\"ready\");\n    },\n    isFunction: function (e) {\n      return v.type(e) === \"function\";\n    },\n    isArray: Array.isArray || function (e) {\n      return v.type(e) === \"array\";\n    },\n    isWindow: function (e) {\n      return e != null && e == e.window;\n    },\n    isNumeric: function (e) {\n      return !isNaN(parseFloat(e)) && isFinite(e);\n    },\n    type: function (e) {\n      return e == null ? String(e) : O[h.call(e)] || \"object\";\n    },\n    isPlainObject: function (e) {\n      if (!e || v.type(e) !== \"object\" || e.nodeType || v.isWindow(e)) return !1;\n\n      try {\n        if (e.constructor && !p.call(e, \"constructor\") && !p.call(e.constructor.prototype, \"isPrototypeOf\")) return !1;\n      } catch (n) {\n        return !1;\n      }\n\n      var r;\n\n      for (r in e);\n\n      return r === t || p.call(e, r);\n    },\n    isEmptyObject: function (e) {\n      var t;\n\n      for (t in e) return !1;\n\n      return !0;\n    },\n    error: function (e) {\n      throw new Error(e);\n    },\n    parseHTML: function (e, t, n) {\n      var r;\n      return !e || typeof e != \"string\" ? null : (typeof t == \"boolean\" && (n = t, t = 0), t = t || i, (r = E.exec(e)) ? [t.createElement(r[1])] : (r = v.buildFragment([e], t, n ? null : []), v.merge([], (r.cacheable ? v.clone(r.fragment) : r.fragment).childNodes)));\n    },\n    parseJSON: function (t) {\n      if (!t || typeof t != \"string\") return null;\n      t = v.trim(t);\n      if (e.JSON && e.JSON.parse) return e.JSON.parse(t);\n      if (S.test(t.replace(T, \"@\").replace(N, \"]\").replace(x, \"\"))) return new Function(\"return \" + t)();\n      v.error(\"Invalid JSON: \" + t);\n    },\n    parseXML: function (n) {\n      var r, i;\n      if (!n || typeof n != \"string\") return null;\n\n      try {\n        e.DOMParser ? (i = new DOMParser(), r = i.parseFromString(n, \"text/xml\")) : (r = new ActiveXObject(\"Microsoft.XMLDOM\"), r.async = \"false\", r.loadXML(n));\n      } catch (s) {\n        r = t;\n      }\n\n      return (!r || !r.documentElement || r.getElementsByTagName(\"parsererror\").length) && v.error(\"Invalid XML: \" + n), r;\n    },\n    noop: function () {},\n    globalEval: function (t) {\n      t && g.test(t) && (e.execScript || function (t) {\n        e.eval.call(e, t);\n      })(t);\n    },\n    camelCase: function (e) {\n      return e.replace(C, \"ms-\").replace(k, L);\n    },\n    nodeName: function (e, t) {\n      return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();\n    },\n    each: function (e, n, r) {\n      var i,\n          s = 0,\n          o = e.length,\n          u = o === t || v.isFunction(e);\n\n      if (r) {\n        if (u) {\n          for (i in e) if (n.apply(e[i], r) === !1) break;\n        } else for (; s < o;) if (n.apply(e[s++], r) === !1) break;\n      } else if (u) {\n        for (i in e) if (n.call(e[i], i, e[i]) === !1) break;\n      } else for (; s < o;) if (n.call(e[s], s, e[s++]) === !1) break;\n\n      return e;\n    },\n    trim: d && !d.call(\"\\ufeff\\u00a0\") ? function (e) {\n      return e == null ? \"\" : d.call(e);\n    } : function (e) {\n      return e == null ? \"\" : (e + \"\").replace(b, \"\");\n    },\n    makeArray: function (e, t) {\n      var n,\n          r = t || [];\n      return e != null && (n = v.type(e), e.length == null || n === \"string\" || n === \"function\" || n === \"regexp\" || v.isWindow(e) ? f.call(r, e) : v.merge(r, e)), r;\n    },\n    inArray: function (e, t, n) {\n      var r;\n\n      if (t) {\n        if (c) return c.call(t, e, n);\n        r = t.length, n = n ? n < 0 ? Math.max(0, r + n) : n : 0;\n\n        for (; n < r; n++) if (n in t && t[n] === e) return n;\n      }\n\n      return -1;\n    },\n    merge: function (e, n) {\n      var r = n.length,\n          i = e.length,\n          s = 0;\n      if (typeof r == \"number\") for (; s < r; s++) e[i++] = n[s];else while (n[s] !== t) e[i++] = n[s++];\n      return e.length = i, e;\n    },\n    grep: function (e, t, n) {\n      var r,\n          i = [],\n          s = 0,\n          o = e.length;\n      n = !!n;\n\n      for (; s < o; s++) r = !!t(e[s], s), n !== r && i.push(e[s]);\n\n      return i;\n    },\n    map: function (e, n, r) {\n      var i,\n          s,\n          o = [],\n          u = 0,\n          a = e.length,\n          f = e instanceof v || a !== t && typeof a == \"number\" && (a > 0 && e[0] && e[a - 1] || a === 0 || v.isArray(e));\n      if (f) for (; u < a; u++) i = n(e[u], u, r), i != null && (o[o.length] = i);else for (s in e) i = n(e[s], s, r), i != null && (o[o.length] = i);\n      return o.concat.apply([], o);\n    },\n    guid: 1,\n    proxy: function (e, n) {\n      var r, i, s;\n      return typeof n == \"string\" && (r = e[n], n = e, e = r), v.isFunction(e) ? (i = l.call(arguments, 2), s = function () {\n        return e.apply(n, i.concat(l.call(arguments)));\n      }, s.guid = e.guid = e.guid || v.guid++, s) : t;\n    },\n    access: function (e, n, r, i, s, o, u) {\n      var a,\n          f = r == null,\n          l = 0,\n          c = e.length;\n\n      if (r && typeof r == \"object\") {\n        for (l in r) v.access(e, n, l, r[l], 1, o, i);\n\n        s = 1;\n      } else if (i !== t) {\n        a = u === t && v.isFunction(i), f && (a ? (a = n, n = function (e, t, n) {\n          return a.call(v(e), n);\n        }) : (n.call(e, i), n = null));\n        if (n) for (; l < c; l++) n(e[l], r, a ? i.call(e[l], l, n(e[l], r)) : i, u);\n        s = 1;\n      }\n\n      return s ? e : f ? n.call(e) : c ? n(e[0], r) : o;\n    },\n    now: function () {\n      return new Date().getTime();\n    }\n  }), v.ready.promise = function (t) {\n    if (!r) {\n      r = v.Deferred();\n      if (i.readyState === \"complete\") setTimeout(v.ready, 1);else if (i.addEventListener) i.addEventListener(\"DOMContentLoaded\", A, !1), e.addEventListener(\"load\", v.ready, !1);else {\n        i.attachEvent(\"onreadystatechange\", A), e.attachEvent(\"onload\", v.ready);\n        var n = !1;\n\n        try {\n          n = e.frameElement == null && i.documentElement;\n        } catch (s) {}\n\n        n && n.doScroll && function o() {\n          if (!v.isReady) {\n            try {\n              n.doScroll(\"left\");\n            } catch (e) {\n              return setTimeout(o, 50);\n            }\n\n            v.ready();\n          }\n        }();\n      }\n    }\n\n    return r.promise(t);\n  }, v.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function (e, t) {\n    O[\"[object \" + t + \"]\"] = t.toLowerCase();\n  }), n = v(i);\n  var M = {};\n  v.Callbacks = function (e) {\n    e = typeof e == \"string\" ? M[e] || _(e) : v.extend({}, e);\n\n    var n,\n        r,\n        i,\n        s,\n        o,\n        u,\n        a = [],\n        f = !e.once && [],\n        l = function (t) {\n      n = e.memory && t, r = !0, u = s || 0, s = 0, o = a.length, i = !0;\n\n      for (; a && u < o; u++) if (a[u].apply(t[0], t[1]) === !1 && e.stopOnFalse) {\n        n = !1;\n        break;\n      }\n\n      i = !1, a && (f ? f.length && l(f.shift()) : n ? a = [] : c.disable());\n    },\n        c = {\n      add: function () {\n        if (a) {\n          var t = a.length;\n          (function r(t) {\n            v.each(t, function (t, n) {\n              var i = v.type(n);\n              i === \"function\" ? (!e.unique || !c.has(n)) && a.push(n) : n && n.length && i !== \"string\" && r(n);\n            });\n          })(arguments), i ? o = a.length : n && (s = t, l(n));\n        }\n\n        return this;\n      },\n      remove: function () {\n        return a && v.each(arguments, function (e, t) {\n          var n;\n\n          while ((n = v.inArray(t, a, n)) > -1) a.splice(n, 1), i && (n <= o && o--, n <= u && u--);\n        }), this;\n      },\n      has: function (e) {\n        return v.inArray(e, a) > -1;\n      },\n      empty: function () {\n        return a = [], this;\n      },\n      disable: function () {\n        return a = f = n = t, this;\n      },\n      disabled: function () {\n        return !a;\n      },\n      lock: function () {\n        return f = t, n || c.disable(), this;\n      },\n      locked: function () {\n        return !f;\n      },\n      fireWith: function (e, t) {\n        return t = t || [], t = [e, t.slice ? t.slice() : t], a && (!r || f) && (i ? f.push(t) : l(t)), this;\n      },\n      fire: function () {\n        return c.fireWith(this, arguments), this;\n      },\n      fired: function () {\n        return !!r;\n      }\n    };\n\n    return c;\n  }, v.extend({\n    Deferred: function (e) {\n      var t = [[\"resolve\", \"done\", v.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", v.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", v.Callbacks(\"memory\")]],\n          n = \"pending\",\n          r = {\n        state: function () {\n          return n;\n        },\n        always: function () {\n          return i.done(arguments).fail(arguments), this;\n        },\n        then: function () {\n          var e = arguments;\n          return v.Deferred(function (n) {\n            v.each(t, function (t, r) {\n              var s = r[0],\n                  o = e[t];\n              i[r[1]](v.isFunction(o) ? function () {\n                var e = o.apply(this, arguments);\n                e && v.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[s + \"With\"](this === i ? n : this, [e]);\n              } : n[s]);\n            }), e = null;\n          }).promise();\n        },\n        promise: function (e) {\n          return e != null ? v.extend(e, r) : r;\n        }\n      },\n          i = {};\n      return r.pipe = r.then, v.each(t, function (e, s) {\n        var o = s[2],\n            u = s[3];\n        r[s[1]] = o.add, u && o.add(function () {\n          n = u;\n        }, t[e ^ 1][2].disable, t[2][2].lock), i[s[0]] = o.fire, i[s[0] + \"With\"] = o.fireWith;\n      }), r.promise(i), e && e.call(i, i), i;\n    },\n    when: function (e) {\n      var t = 0,\n          n = l.call(arguments),\n          r = n.length,\n          i = r !== 1 || e && v.isFunction(e.promise) ? r : 0,\n          s = i === 1 ? e : v.Deferred(),\n          o = function (e, t, n) {\n        return function (r) {\n          t[e] = this, n[e] = arguments.length > 1 ? l.call(arguments) : r, n === u ? s.notifyWith(t, n) : --i || s.resolveWith(t, n);\n        };\n      },\n          u,\n          a,\n          f;\n\n      if (r > 1) {\n        u = new Array(r), a = new Array(r), f = new Array(r);\n\n        for (; t < r; t++) n[t] && v.isFunction(n[t].promise) ? n[t].promise().done(o(t, f, n)).fail(s.reject).progress(o(t, a, u)) : --i;\n      }\n\n      return i || s.resolveWith(f, n), s.promise();\n    }\n  }), v.support = function () {\n    var t,\n        n,\n        r,\n        s,\n        o,\n        u,\n        a,\n        f,\n        l,\n        c,\n        h,\n        p = i.createElement(\"div\");\n    p.setAttribute(\"className\", \"t\"), p.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\", n = p.getElementsByTagName(\"*\"), r = p.getElementsByTagName(\"a\")[0];\n    if (!n || !r || !n.length) return {};\n    s = i.createElement(\"select\"), o = s.appendChild(i.createElement(\"option\")), u = p.getElementsByTagName(\"input\")[0], r.style.cssText = \"top:1px;float:left;opacity:.5\", t = {\n      leadingWhitespace: p.firstChild.nodeType === 3,\n      tbody: !p.getElementsByTagName(\"tbody\").length,\n      htmlSerialize: !!p.getElementsByTagName(\"link\").length,\n      style: /top/.test(r.getAttribute(\"style\")),\n      hrefNormalized: r.getAttribute(\"href\") === \"/a\",\n      opacity: /^0.5/.test(r.style.opacity),\n      cssFloat: !!r.style.cssFloat,\n      checkOn: u.value === \"on\",\n      optSelected: o.selected,\n      getSetAttribute: p.className !== \"t\",\n      enctype: !!i.createElement(\"form\").enctype,\n      html5Clone: i.createElement(\"nav\").cloneNode(!0).outerHTML !== \"<:nav></:nav>\",\n      boxModel: i.compatMode === \"CSS1Compat\",\n      submitBubbles: !0,\n      changeBubbles: !0,\n      focusinBubbles: !1,\n      deleteExpando: !0,\n      noCloneEvent: !0,\n      inlineBlockNeedsLayout: !1,\n      shrinkWrapBlocks: !1,\n      reliableMarginRight: !0,\n      boxSizingReliable: !0,\n      pixelPosition: !1\n    }, u.checked = !0, t.noCloneChecked = u.cloneNode(!0).checked, s.disabled = !0, t.optDisabled = !o.disabled;\n\n    try {\n      delete p.test;\n    } catch (d) {\n      t.deleteExpando = !1;\n    }\n\n    !p.addEventListener && p.attachEvent && p.fireEvent && (p.attachEvent(\"onclick\", h = function () {\n      t.noCloneEvent = !1;\n    }), p.cloneNode(!0).fireEvent(\"onclick\"), p.detachEvent(\"onclick\", h)), u = i.createElement(\"input\"), u.value = \"t\", u.setAttribute(\"type\", \"radio\"), t.radioValue = u.value === \"t\", u.setAttribute(\"checked\", \"checked\"), u.setAttribute(\"name\", \"t\"), p.appendChild(u), a = i.createDocumentFragment(), a.appendChild(p.lastChild), t.checkClone = a.cloneNode(!0).cloneNode(!0).lastChild.checked, t.appendChecked = u.checked, a.removeChild(u), a.appendChild(p);\n    if (p.attachEvent) for (l in {\n      submit: !0,\n      change: !0,\n      focusin: !0\n    }) f = \"on\" + l, c = f in p, c || (p.setAttribute(f, \"return;\"), c = typeof p[f] == \"function\"), t[l + \"Bubbles\"] = c;\n    return v(function () {\n      var n,\n          r,\n          s,\n          o,\n          u = \"padding:0;margin:0;border:0;display:block;overflow:hidden;\",\n          a = i.getElementsByTagName(\"body\")[0];\n      if (!a) return;\n      n = i.createElement(\"div\"), n.style.cssText = \"visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px\", a.insertBefore(n, a.firstChild), r = i.createElement(\"div\"), n.appendChild(r), r.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\", s = r.getElementsByTagName(\"td\"), s[0].style.cssText = \"padding:0;margin:0;border:0;display:none\", c = s[0].offsetHeight === 0, s[0].style.display = \"\", s[1].style.display = \"none\", t.reliableHiddenOffsets = c && s[0].offsetHeight === 0, r.innerHTML = \"\", r.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\", t.boxSizing = r.offsetWidth === 4, t.doesNotIncludeMarginInBodyOffset = a.offsetTop !== 1, e.getComputedStyle && (t.pixelPosition = (e.getComputedStyle(r, null) || {}).top !== \"1%\", t.boxSizingReliable = (e.getComputedStyle(r, null) || {\n        width: \"4px\"\n      }).width === \"4px\", o = i.createElement(\"div\"), o.style.cssText = r.style.cssText = u, o.style.marginRight = o.style.width = \"0\", r.style.width = \"1px\", r.appendChild(o), t.reliableMarginRight = !parseFloat((e.getComputedStyle(o, null) || {}).marginRight)), typeof r.style.zoom != \"undefined\" && (r.innerHTML = \"\", r.style.cssText = u + \"width:1px;padding:1px;display:inline;zoom:1\", t.inlineBlockNeedsLayout = r.offsetWidth === 3, r.style.display = \"block\", r.style.overflow = \"visible\", r.innerHTML = \"<div></div>\", r.firstChild.style.width = \"5px\", t.shrinkWrapBlocks = r.offsetWidth !== 3, n.style.zoom = 1), a.removeChild(n), n = r = s = o = null;\n    }), a.removeChild(p), n = r = s = o = u = a = p = null, t;\n  }();\n  var D = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n      P = /([A-Z])/g;\n  v.extend({\n    cache: {},\n    deletedIds: [],\n    uuid: 0,\n    expando: \"jQuery\" + (v.fn.jquery + Math.random()).replace(/\\D/g, \"\"),\n    noData: {\n      embed: !0,\n      object: \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n      applet: !0\n    },\n    hasData: function (e) {\n      return e = e.nodeType ? v.cache[e[v.expando]] : e[v.expando], !!e && !B(e);\n    },\n    data: function (e, n, r, i) {\n      if (!v.acceptData(e)) return;\n      var s,\n          o,\n          u = v.expando,\n          a = typeof n == \"string\",\n          f = e.nodeType,\n          l = f ? v.cache : e,\n          c = f ? e[u] : e[u] && u;\n      if ((!c || !l[c] || !i && !l[c].data) && a && r === t) return;\n      c || (f ? e[u] = c = v.deletedIds.pop() || v.guid++ : c = u), l[c] || (l[c] = {}, f || (l[c].toJSON = v.noop));\n      if (typeof n == \"object\" || typeof n == \"function\") i ? l[c] = v.extend(l[c], n) : l[c].data = v.extend(l[c].data, n);\n      return s = l[c], i || (s.data || (s.data = {}), s = s.data), r !== t && (s[v.camelCase(n)] = r), a ? (o = s[n], o == null && (o = s[v.camelCase(n)])) : o = s, o;\n    },\n    removeData: function (e, t, n) {\n      if (!v.acceptData(e)) return;\n      var r,\n          i,\n          s,\n          o = e.nodeType,\n          u = o ? v.cache : e,\n          a = o ? e[v.expando] : v.expando;\n      if (!u[a]) return;\n\n      if (t) {\n        r = n ? u[a] : u[a].data;\n\n        if (r) {\n          v.isArray(t) || (t in r ? t = [t] : (t = v.camelCase(t), t in r ? t = [t] : t = t.split(\" \")));\n\n          for (i = 0, s = t.length; i < s; i++) delete r[t[i]];\n\n          if (!(n ? B : v.isEmptyObject)(r)) return;\n        }\n      }\n\n      if (!n) {\n        delete u[a].data;\n        if (!B(u[a])) return;\n      }\n\n      o ? v.cleanData([e], !0) : v.support.deleteExpando || u != u.window ? delete u[a] : u[a] = null;\n    },\n    _data: function (e, t, n) {\n      return v.data(e, t, n, !0);\n    },\n    acceptData: function (e) {\n      var t = e.nodeName && v.noData[e.nodeName.toLowerCase()];\n      return !t || t !== !0 && e.getAttribute(\"classid\") === t;\n    }\n  }), v.fn.extend({\n    data: function (e, n) {\n      var r,\n          i,\n          s,\n          o,\n          u,\n          a = this[0],\n          f = 0,\n          l = null;\n\n      if (e === t) {\n        if (this.length) {\n          l = v.data(a);\n\n          if (a.nodeType === 1 && !v._data(a, \"parsedAttrs\")) {\n            s = a.attributes;\n\n            for (u = s.length; f < u; f++) o = s[f].name, o.indexOf(\"data-\") || (o = v.camelCase(o.substring(5)), H(a, o, l[o]));\n\n            v._data(a, \"parsedAttrs\", !0);\n          }\n        }\n\n        return l;\n      }\n\n      return typeof e == \"object\" ? this.each(function () {\n        v.data(this, e);\n      }) : (r = e.split(\".\", 2), r[1] = r[1] ? \".\" + r[1] : \"\", i = r[1] + \"!\", v.access(this, function (n) {\n        if (n === t) return l = this.triggerHandler(\"getData\" + i, [r[0]]), l === t && a && (l = v.data(a, e), l = H(a, e, l)), l === t && r[1] ? this.data(r[0]) : l;\n        r[1] = n, this.each(function () {\n          var t = v(this);\n          t.triggerHandler(\"setData\" + i, r), v.data(this, e, n), t.triggerHandler(\"changeData\" + i, r);\n        });\n      }, null, n, arguments.length > 1, null, !1));\n    },\n    removeData: function (e) {\n      return this.each(function () {\n        v.removeData(this, e);\n      });\n    }\n  }), v.extend({\n    queue: function (e, t, n) {\n      var r;\n      if (e) return t = (t || \"fx\") + \"queue\", r = v._data(e, t), n && (!r || v.isArray(n) ? r = v._data(e, t, v.makeArray(n)) : r.push(n)), r || [];\n    },\n    dequeue: function (e, t) {\n      t = t || \"fx\";\n\n      var n = v.queue(e, t),\n          r = n.length,\n          i = n.shift(),\n          s = v._queueHooks(e, t),\n          o = function () {\n        v.dequeue(e, t);\n      };\n\n      i === \"inprogress\" && (i = n.shift(), r--), i && (t === \"fx\" && n.unshift(\"inprogress\"), delete s.stop, i.call(e, o, s)), !r && s && s.empty.fire();\n    },\n    _queueHooks: function (e, t) {\n      var n = t + \"queueHooks\";\n      return v._data(e, n) || v._data(e, n, {\n        empty: v.Callbacks(\"once memory\").add(function () {\n          v.removeData(e, t + \"queue\", !0), v.removeData(e, n, !0);\n        })\n      });\n    }\n  }), v.fn.extend({\n    queue: function (e, n) {\n      var r = 2;\n      return typeof e != \"string\" && (n = e, e = \"fx\", r--), arguments.length < r ? v.queue(this[0], e) : n === t ? this : this.each(function () {\n        var t = v.queue(this, e, n);\n        v._queueHooks(this, e), e === \"fx\" && t[0] !== \"inprogress\" && v.dequeue(this, e);\n      });\n    },\n    dequeue: function (e) {\n      return this.each(function () {\n        v.dequeue(this, e);\n      });\n    },\n    delay: function (e, t) {\n      return e = v.fx ? v.fx.speeds[e] || e : e, t = t || \"fx\", this.queue(t, function (t, n) {\n        var r = setTimeout(t, e);\n\n        n.stop = function () {\n          clearTimeout(r);\n        };\n      });\n    },\n    clearQueue: function (e) {\n      return this.queue(e || \"fx\", []);\n    },\n    promise: function (e, n) {\n      var r,\n          i = 1,\n          s = v.Deferred(),\n          o = this,\n          u = this.length,\n          a = function () {\n        --i || s.resolveWith(o, [o]);\n      };\n\n      typeof e != \"string\" && (n = e, e = t), e = e || \"fx\";\n\n      while (u--) r = v._data(o[u], e + \"queueHooks\"), r && r.empty && (i++, r.empty.add(a));\n\n      return a(), s.promise(n);\n    }\n  });\n  var j,\n      F,\n      I,\n      q = /[\\t\\r\\n]/g,\n      R = /\\r/g,\n      U = /^(?:button|input)$/i,\n      z = /^(?:button|input|object|select|textarea)$/i,\n      W = /^a(?:rea|)$/i,\n      X = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,\n      V = v.support.getSetAttribute;\n  v.fn.extend({\n    attr: function (e, t) {\n      return v.access(this, v.attr, e, t, arguments.length > 1);\n    },\n    removeAttr: function (e) {\n      return this.each(function () {\n        v.removeAttr(this, e);\n      });\n    },\n    prop: function (e, t) {\n      return v.access(this, v.prop, e, t, arguments.length > 1);\n    },\n    removeProp: function (e) {\n      return e = v.propFix[e] || e, this.each(function () {\n        try {\n          this[e] = t, delete this[e];\n        } catch (n) {}\n      });\n    },\n    addClass: function (e) {\n      var t, n, r, i, s, o, u;\n      if (v.isFunction(e)) return this.each(function (t) {\n        v(this).addClass(e.call(this, t, this.className));\n      });\n\n      if (e && typeof e == \"string\") {\n        t = e.split(y);\n\n        for (n = 0, r = this.length; n < r; n++) {\n          i = this[n];\n          if (i.nodeType === 1) if (!i.className && t.length === 1) i.className = e;else {\n            s = \" \" + i.className + \" \";\n\n            for (o = 0, u = t.length; o < u; o++) s.indexOf(\" \" + t[o] + \" \") < 0 && (s += t[o] + \" \");\n\n            i.className = v.trim(s);\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function (e) {\n      var n, r, i, s, o, u, a;\n      if (v.isFunction(e)) return this.each(function (t) {\n        v(this).removeClass(e.call(this, t, this.className));\n      });\n\n      if (e && typeof e == \"string\" || e === t) {\n        n = (e || \"\").split(y);\n\n        for (u = 0, a = this.length; u < a; u++) {\n          i = this[u];\n\n          if (i.nodeType === 1 && i.className) {\n            r = (\" \" + i.className + \" \").replace(q, \" \");\n\n            for (s = 0, o = n.length; s < o; s++) while (r.indexOf(\" \" + n[s] + \" \") >= 0) r = r.replace(\" \" + n[s] + \" \", \" \");\n\n            i.className = e ? v.trim(r) : \"\";\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function (e, t) {\n      var n = typeof e,\n          r = typeof t == \"boolean\";\n      return v.isFunction(e) ? this.each(function (n) {\n        v(this).toggleClass(e.call(this, n, this.className, t), t);\n      }) : this.each(function () {\n        if (n === \"string\") {\n          var i,\n              s = 0,\n              o = v(this),\n              u = t,\n              a = e.split(y);\n\n          while (i = a[s++]) u = r ? u : !o.hasClass(i), o[u ? \"addClass\" : \"removeClass\"](i);\n        } else if (n === \"undefined\" || n === \"boolean\") this.className && v._data(this, \"__className__\", this.className), this.className = this.className || e === !1 ? \"\" : v._data(this, \"__className__\") || \"\";\n      });\n    },\n    hasClass: function (e) {\n      var t = \" \" + e + \" \",\n          n = 0,\n          r = this.length;\n\n      for (; n < r; n++) if (this[n].nodeType === 1 && (\" \" + this[n].className + \" \").replace(q, \" \").indexOf(t) >= 0) return !0;\n\n      return !1;\n    },\n    val: function (e) {\n      var n,\n          r,\n          i,\n          s = this[0];\n\n      if (!arguments.length) {\n        if (s) return n = v.valHooks[s.type] || v.valHooks[s.nodeName.toLowerCase()], n && \"get\" in n && (r = n.get(s, \"value\")) !== t ? r : (r = s.value, typeof r == \"string\" ? r.replace(R, \"\") : r == null ? \"\" : r);\n        return;\n      }\n\n      return i = v.isFunction(e), this.each(function (r) {\n        var s,\n            o = v(this);\n        if (this.nodeType !== 1) return;\n        i ? s = e.call(this, r, o.val()) : s = e, s == null ? s = \"\" : typeof s == \"number\" ? s += \"\" : v.isArray(s) && (s = v.map(s, function (e) {\n          return e == null ? \"\" : e + \"\";\n        })), n = v.valHooks[this.type] || v.valHooks[this.nodeName.toLowerCase()];\n        if (!n || !(\"set\" in n) || n.set(this, s, \"value\") === t) this.value = s;\n      });\n    }\n  }), v.extend({\n    valHooks: {\n      option: {\n        get: function (e) {\n          var t = e.attributes.value;\n          return !t || t.specified ? e.value : e.text;\n        }\n      },\n      select: {\n        get: function (e) {\n          var t,\n              n,\n              r = e.options,\n              i = e.selectedIndex,\n              s = e.type === \"select-one\" || i < 0,\n              o = s ? null : [],\n              u = s ? i + 1 : r.length,\n              a = i < 0 ? u : s ? i : 0;\n\n          for (; a < u; a++) {\n            n = r[a];\n\n            if ((n.selected || a === i) && (v.support.optDisabled ? !n.disabled : n.getAttribute(\"disabled\") === null) && (!n.parentNode.disabled || !v.nodeName(n.parentNode, \"optgroup\"))) {\n              t = v(n).val();\n              if (s) return t;\n              o.push(t);\n            }\n          }\n\n          return o;\n        },\n        set: function (e, t) {\n          var n = v.makeArray(t);\n          return v(e).find(\"option\").each(function () {\n            this.selected = v.inArray(v(this).val(), n) >= 0;\n          }), n.length || (e.selectedIndex = -1), n;\n        }\n      }\n    },\n    attrFn: {},\n    attr: function (e, n, r, i) {\n      var s,\n          o,\n          u,\n          a = e.nodeType;\n      if (!e || a === 3 || a === 8 || a === 2) return;\n      if (i && v.isFunction(v.fn[n])) return v(e)[n](r);\n      if (typeof e.getAttribute == \"undefined\") return v.prop(e, n, r);\n      u = a !== 1 || !v.isXMLDoc(e), u && (n = n.toLowerCase(), o = v.attrHooks[n] || (X.test(n) ? F : j));\n\n      if (r !== t) {\n        if (r === null) {\n          v.removeAttr(e, n);\n          return;\n        }\n\n        return o && \"set\" in o && u && (s = o.set(e, r, n)) !== t ? s : (e.setAttribute(n, r + \"\"), r);\n      }\n\n      return o && \"get\" in o && u && (s = o.get(e, n)) !== null ? s : (s = e.getAttribute(n), s === null ? t : s);\n    },\n    removeAttr: function (e, t) {\n      var n,\n          r,\n          i,\n          s,\n          o = 0;\n\n      if (t && e.nodeType === 1) {\n        r = t.split(y);\n\n        for (; o < r.length; o++) i = r[o], i && (n = v.propFix[i] || i, s = X.test(i), s || v.attr(e, i, \"\"), e.removeAttribute(V ? i : n), s && n in e && (e[n] = !1));\n      }\n    },\n    attrHooks: {\n      type: {\n        set: function (e, t) {\n          if (U.test(e.nodeName) && e.parentNode) v.error(\"type property can't be changed\");else if (!v.support.radioValue && t === \"radio\" && v.nodeName(e, \"input\")) {\n            var n = e.value;\n            return e.setAttribute(\"type\", t), n && (e.value = n), t;\n          }\n        }\n      },\n      value: {\n        get: function (e, t) {\n          return j && v.nodeName(e, \"button\") ? j.get(e, t) : t in e ? e.value : null;\n        },\n        set: function (e, t, n) {\n          if (j && v.nodeName(e, \"button\")) return j.set(e, t, n);\n          e.value = t;\n        }\n      }\n    },\n    propFix: {\n      tabindex: \"tabIndex\",\n      readonly: \"readOnly\",\n      \"for\": \"htmlFor\",\n      \"class\": \"className\",\n      maxlength: \"maxLength\",\n      cellspacing: \"cellSpacing\",\n      cellpadding: \"cellPadding\",\n      rowspan: \"rowSpan\",\n      colspan: \"colSpan\",\n      usemap: \"useMap\",\n      frameborder: \"frameBorder\",\n      contenteditable: \"contentEditable\"\n    },\n    prop: function (e, n, r) {\n      var i,\n          s,\n          o,\n          u = e.nodeType;\n      if (!e || u === 3 || u === 8 || u === 2) return;\n      return o = u !== 1 || !v.isXMLDoc(e), o && (n = v.propFix[n] || n, s = v.propHooks[n]), r !== t ? s && \"set\" in s && (i = s.set(e, r, n)) !== t ? i : e[n] = r : s && \"get\" in s && (i = s.get(e, n)) !== null ? i : e[n];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function (e) {\n          var n = e.getAttributeNode(\"tabindex\");\n          return n && n.specified ? parseInt(n.value, 10) : z.test(e.nodeName) || W.test(e.nodeName) && e.href ? 0 : t;\n        }\n      }\n    }\n  }), F = {\n    get: function (e, n) {\n      var r,\n          i = v.prop(e, n);\n      return i === !0 || typeof i != \"boolean\" && (r = e.getAttributeNode(n)) && r.nodeValue !== !1 ? n.toLowerCase() : t;\n    },\n    set: function (e, t, n) {\n      var r;\n      return t === !1 ? v.removeAttr(e, n) : (r = v.propFix[n] || n, r in e && (e[r] = !0), e.setAttribute(n, n.toLowerCase())), n;\n    }\n  }, V || (I = {\n    name: !0,\n    id: !0,\n    coords: !0\n  }, j = v.valHooks.button = {\n    get: function (e, n) {\n      var r;\n      return r = e.getAttributeNode(n), r && (I[n] ? r.value !== \"\" : r.specified) ? r.value : t;\n    },\n    set: function (e, t, n) {\n      var r = e.getAttributeNode(n);\n      return r || (r = i.createAttribute(n), e.setAttributeNode(r)), r.value = t + \"\";\n    }\n  }, v.each([\"width\", \"height\"], function (e, t) {\n    v.attrHooks[t] = v.extend(v.attrHooks[t], {\n      set: function (e, n) {\n        if (n === \"\") return e.setAttribute(t, \"auto\"), n;\n      }\n    });\n  }), v.attrHooks.contenteditable = {\n    get: j.get,\n    set: function (e, t, n) {\n      t === \"\" && (t = \"false\"), j.set(e, t, n);\n    }\n  }), v.support.hrefNormalized || v.each([\"href\", \"src\", \"width\", \"height\"], function (e, n) {\n    v.attrHooks[n] = v.extend(v.attrHooks[n], {\n      get: function (e) {\n        var r = e.getAttribute(n, 2);\n        return r === null ? t : r;\n      }\n    });\n  }), v.support.style || (v.attrHooks.style = {\n    get: function (e) {\n      return e.style.cssText.toLowerCase() || t;\n    },\n    set: function (e, t) {\n      return e.style.cssText = t + \"\";\n    }\n  }), v.support.optSelected || (v.propHooks.selected = v.extend(v.propHooks.selected, {\n    get: function (e) {\n      var t = e.parentNode;\n      return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null;\n    }\n  })), v.support.enctype || (v.propFix.enctype = \"encoding\"), v.support.checkOn || v.each([\"radio\", \"checkbox\"], function () {\n    v.valHooks[this] = {\n      get: function (e) {\n        return e.getAttribute(\"value\") === null ? \"on\" : e.value;\n      }\n    };\n  }), v.each([\"radio\", \"checkbox\"], function () {\n    v.valHooks[this] = v.extend(v.valHooks[this], {\n      set: function (e, t) {\n        if (v.isArray(t)) return e.checked = v.inArray(v(e).val(), t) >= 0;\n      }\n    });\n  });\n\n  var $ = /^(?:textarea|input|select)$/i,\n      J = /^([^\\.]*|)(?:\\.(.+)|)$/,\n      K = /(?:^|\\s)hover(\\.\\S+|)\\b/,\n      Q = /^key/,\n      G = /^(?:mouse|contextmenu)|click/,\n      Y = /^(?:focusinfocus|focusoutblur)$/,\n      Z = function (e) {\n    return v.event.special.hover ? e : e.replace(K, \"mouseenter$1 mouseleave$1\");\n  };\n\n  v.event = {\n    add: function (e, n, r, i, s) {\n      var o, u, a, f, l, c, h, p, d, m, g;\n      if (e.nodeType === 3 || e.nodeType === 8 || !n || !r || !(o = v._data(e))) return;\n      r.handler && (d = r, r = d.handler, s = d.selector), r.guid || (r.guid = v.guid++), a = o.events, a || (o.events = a = {}), u = o.handle, u || (o.handle = u = function (e) {\n        return typeof v == \"undefined\" || !!e && v.event.triggered === e.type ? t : v.event.dispatch.apply(u.elem, arguments);\n      }, u.elem = e), n = v.trim(Z(n)).split(\" \");\n\n      for (f = 0; f < n.length; f++) {\n        l = J.exec(n[f]) || [], c = l[1], h = (l[2] || \"\").split(\".\").sort(), g = v.event.special[c] || {}, c = (s ? g.delegateType : g.bindType) || c, g = v.event.special[c] || {}, p = v.extend({\n          type: c,\n          origType: l[1],\n          data: i,\n          handler: r,\n          guid: r.guid,\n          selector: s,\n          needsContext: s && v.expr.match.needsContext.test(s),\n          namespace: h.join(\".\")\n        }, d), m = a[c];\n\n        if (!m) {\n          m = a[c] = [], m.delegateCount = 0;\n          if (!g.setup || g.setup.call(e, i, h, u) === !1) e.addEventListener ? e.addEventListener(c, u, !1) : e.attachEvent && e.attachEvent(\"on\" + c, u);\n        }\n\n        g.add && (g.add.call(e, p), p.handler.guid || (p.handler.guid = r.guid)), s ? m.splice(m.delegateCount++, 0, p) : m.push(p), v.event.global[c] = !0;\n      }\n\n      e = null;\n    },\n    global: {},\n    remove: function (e, t, n, r, i) {\n      var s,\n          o,\n          u,\n          a,\n          f,\n          l,\n          c,\n          h,\n          p,\n          d,\n          m,\n          g = v.hasData(e) && v._data(e);\n\n      if (!g || !(h = g.events)) return;\n      t = v.trim(Z(t || \"\")).split(\" \");\n\n      for (s = 0; s < t.length; s++) {\n        o = J.exec(t[s]) || [], u = a = o[1], f = o[2];\n\n        if (!u) {\n          for (u in h) v.event.remove(e, u + t[s], n, r, !0);\n\n          continue;\n        }\n\n        p = v.event.special[u] || {}, u = (r ? p.delegateType : p.bindType) || u, d = h[u] || [], l = d.length, f = f ? new RegExp(\"(^|\\\\.)\" + f.split(\".\").sort().join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n\n        for (c = 0; c < d.length; c++) m = d[c], (i || a === m.origType) && (!n || n.guid === m.guid) && (!f || f.test(m.namespace)) && (!r || r === m.selector || r === \"**\" && m.selector) && (d.splice(c--, 1), m.selector && d.delegateCount--, p.remove && p.remove.call(e, m));\n\n        d.length === 0 && l !== d.length && ((!p.teardown || p.teardown.call(e, f, g.handle) === !1) && v.removeEvent(e, u, g.handle), delete h[u]);\n      }\n\n      v.isEmptyObject(h) && (delete g.handle, v.removeData(e, \"events\", !0));\n    },\n    customEvent: {\n      getData: !0,\n      setData: !0,\n      changeData: !0\n    },\n    trigger: function (n, r, s, o) {\n      if (!s || s.nodeType !== 3 && s.nodeType !== 8) {\n        var u,\n            a,\n            f,\n            l,\n            c,\n            h,\n            p,\n            d,\n            m,\n            g,\n            y = n.type || n,\n            b = [];\n        if (Y.test(y + v.event.triggered)) return;\n        y.indexOf(\"!\") >= 0 && (y = y.slice(0, -1), a = !0), y.indexOf(\".\") >= 0 && (b = y.split(\".\"), y = b.shift(), b.sort());\n        if ((!s || v.event.customEvent[y]) && !v.event.global[y]) return;\n        n = typeof n == \"object\" ? n[v.expando] ? n : new v.Event(y, n) : new v.Event(y), n.type = y, n.isTrigger = !0, n.exclusive = a, n.namespace = b.join(\".\"), n.namespace_re = n.namespace ? new RegExp(\"(^|\\\\.)\" + b.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, h = y.indexOf(\":\") < 0 ? \"on\" + y : \"\";\n\n        if (!s) {\n          u = v.cache;\n\n          for (f in u) u[f].events && u[f].events[y] && v.event.trigger(n, r, u[f].handle.elem, !0);\n\n          return;\n        }\n\n        n.result = t, n.target || (n.target = s), r = r != null ? v.makeArray(r) : [], r.unshift(n), p = v.event.special[y] || {};\n        if (p.trigger && p.trigger.apply(s, r) === !1) return;\n        m = [[s, p.bindType || y]];\n\n        if (!o && !p.noBubble && !v.isWindow(s)) {\n          g = p.delegateType || y, l = Y.test(g + y) ? s : s.parentNode;\n\n          for (c = s; l; l = l.parentNode) m.push([l, g]), c = l;\n\n          c === (s.ownerDocument || i) && m.push([c.defaultView || c.parentWindow || e, g]);\n        }\n\n        for (f = 0; f < m.length && !n.isPropagationStopped(); f++) l = m[f][0], n.type = m[f][1], d = (v._data(l, \"events\") || {})[n.type] && v._data(l, \"handle\"), d && d.apply(l, r), d = h && l[h], d && v.acceptData(l) && d.apply && d.apply(l, r) === !1 && n.preventDefault();\n\n        return n.type = y, !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(s.ownerDocument, r) === !1) && (y !== \"click\" || !v.nodeName(s, \"a\")) && v.acceptData(s) && h && s[y] && (y !== \"focus\" && y !== \"blur\" || n.target.offsetWidth !== 0) && !v.isWindow(s) && (c = s[h], c && (s[h] = null), v.event.triggered = y, s[y](), v.event.triggered = t, c && (s[h] = c)), n.result;\n      }\n\n      return;\n    },\n    dispatch: function (n) {\n      n = v.event.fix(n || e.event);\n      var r,\n          i,\n          s,\n          o,\n          u,\n          a,\n          f,\n          c,\n          h,\n          p,\n          d = (v._data(this, \"events\") || {})[n.type] || [],\n          m = d.delegateCount,\n          g = l.call(arguments),\n          y = !n.exclusive && !n.namespace,\n          b = v.event.special[n.type] || {},\n          w = [];\n      g[0] = n, n.delegateTarget = this;\n      if (b.preDispatch && b.preDispatch.call(this, n) === !1) return;\n      if (m && (!n.button || n.type !== \"click\")) for (s = n.target; s != this; s = s.parentNode || this) if (s.disabled !== !0 || n.type !== \"click\") {\n        u = {}, f = [];\n\n        for (r = 0; r < m; r++) c = d[r], h = c.selector, u[h] === t && (u[h] = c.needsContext ? v(h, this).index(s) >= 0 : v.find(h, this, null, [s]).length), u[h] && f.push(c);\n\n        f.length && w.push({\n          elem: s,\n          matches: f\n        });\n      }\n      d.length > m && w.push({\n        elem: this,\n        matches: d.slice(m)\n      });\n\n      for (r = 0; r < w.length && !n.isPropagationStopped(); r++) {\n        a = w[r], n.currentTarget = a.elem;\n\n        for (i = 0; i < a.matches.length && !n.isImmediatePropagationStopped(); i++) {\n          c = a.matches[i];\n          if (y || !n.namespace && !c.namespace || n.namespace_re && n.namespace_re.test(c.namespace)) n.data = c.data, n.handleObj = c, o = ((v.event.special[c.origType] || {}).handle || c.handler).apply(a.elem, g), o !== t && (n.result = o, o === !1 && (n.preventDefault(), n.stopPropagation()));\n        }\n      }\n\n      return b.postDispatch && b.postDispatch.call(this, n), n.result;\n    },\n    props: \"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n    fixHooks: {},\n    keyHooks: {\n      props: \"char charCode key keyCode\".split(\" \"),\n      filter: function (e, t) {\n        return e.which == null && (e.which = t.charCode != null ? t.charCode : t.keyCode), e;\n      }\n    },\n    mouseHooks: {\n      props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n      filter: function (e, n) {\n        var r,\n            s,\n            o,\n            u = n.button,\n            a = n.fromElement;\n        return e.pageX == null && n.clientX != null && (r = e.target.ownerDocument || i, s = r.documentElement, o = r.body, e.pageX = n.clientX + (s && s.scrollLeft || o && o.scrollLeft || 0) - (s && s.clientLeft || o && o.clientLeft || 0), e.pageY = n.clientY + (s && s.scrollTop || o && o.scrollTop || 0) - (s && s.clientTop || o && o.clientTop || 0)), !e.relatedTarget && a && (e.relatedTarget = a === e.target ? n.toElement : a), !e.which && u !== t && (e.which = u & 1 ? 1 : u & 2 ? 3 : u & 4 ? 2 : 0), e;\n      }\n    },\n    fix: function (e) {\n      if (e[v.expando]) return e;\n      var t,\n          n,\n          r = e,\n          s = v.event.fixHooks[e.type] || {},\n          o = s.props ? this.props.concat(s.props) : this.props;\n      e = v.Event(r);\n\n      for (t = o.length; t;) n = o[--t], e[n] = r[n];\n\n      return e.target || (e.target = r.srcElement || i), e.target.nodeType === 3 && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, s.filter ? s.filter(e, r) : e;\n    },\n    special: {\n      load: {\n        noBubble: !0\n      },\n      focus: {\n        delegateType: \"focusin\"\n      },\n      blur: {\n        delegateType: \"focusout\"\n      },\n      beforeunload: {\n        setup: function (e, t, n) {\n          v.isWindow(this) && (this.onbeforeunload = n);\n        },\n        teardown: function (e, t) {\n          this.onbeforeunload === t && (this.onbeforeunload = null);\n        }\n      }\n    },\n    simulate: function (e, t, n, r) {\n      var i = v.extend(new v.Event(), n, {\n        type: e,\n        isSimulated: !0,\n        originalEvent: {}\n      });\n      r ? v.event.trigger(i, null, t) : v.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault();\n    }\n  }, v.event.handle = v.event.dispatch, v.removeEvent = i.removeEventListener ? function (e, t, n) {\n    e.removeEventListener && e.removeEventListener(t, n, !1);\n  } : function (e, t, n) {\n    var r = \"on\" + t;\n    e.detachEvent && (typeof e[r] == \"undefined\" && (e[r] = null), e.detachEvent(r, n));\n  }, v.Event = function (e, t) {\n    if (!(this instanceof v.Event)) return new v.Event(e, t);\n    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? tt : et) : this.type = e, t && v.extend(this, t), this.timeStamp = e && e.timeStamp || v.now(), this[v.expando] = !0;\n  }, v.Event.prototype = {\n    preventDefault: function () {\n      this.isDefaultPrevented = tt;\n      var e = this.originalEvent;\n      if (!e) return;\n      e.preventDefault ? e.preventDefault() : e.returnValue = !1;\n    },\n    stopPropagation: function () {\n      this.isPropagationStopped = tt;\n      var e = this.originalEvent;\n      if (!e) return;\n      e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0;\n    },\n    stopImmediatePropagation: function () {\n      this.isImmediatePropagationStopped = tt, this.stopPropagation();\n    },\n    isDefaultPrevented: et,\n    isPropagationStopped: et,\n    isImmediatePropagationStopped: et\n  }, v.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  }, function (e, t) {\n    v.event.special[e] = {\n      delegateType: t,\n      bindType: t,\n      handle: function (e) {\n        var n,\n            r = this,\n            i = e.relatedTarget,\n            s = e.handleObj,\n            o = s.selector;\n        if (!i || i !== r && !v.contains(r, i)) e.type = s.origType, n = s.handler.apply(this, arguments), e.type = t;\n        return n;\n      }\n    };\n  }), v.support.submitBubbles || (v.event.special.submit = {\n    setup: function () {\n      if (v.nodeName(this, \"form\")) return !1;\n      v.event.add(this, \"click._submit keypress._submit\", function (e) {\n        var n = e.target,\n            r = v.nodeName(n, \"input\") || v.nodeName(n, \"button\") ? n.form : t;\n        r && !v._data(r, \"_submit_attached\") && (v.event.add(r, \"submit._submit\", function (e) {\n          e._submit_bubble = !0;\n        }), v._data(r, \"_submit_attached\", !0));\n      });\n    },\n    postDispatch: function (e) {\n      e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && v.event.simulate(\"submit\", this.parentNode, e, !0));\n    },\n    teardown: function () {\n      if (v.nodeName(this, \"form\")) return !1;\n      v.event.remove(this, \"._submit\");\n    }\n  }), v.support.changeBubbles || (v.event.special.change = {\n    setup: function () {\n      if ($.test(this.nodeName)) {\n        if (this.type === \"checkbox\" || this.type === \"radio\") v.event.add(this, \"propertychange._change\", function (e) {\n          e.originalEvent.propertyName === \"checked\" && (this._just_changed = !0);\n        }), v.event.add(this, \"click._change\", function (e) {\n          this._just_changed && !e.isTrigger && (this._just_changed = !1), v.event.simulate(\"change\", this, e, !0);\n        });\n        return !1;\n      }\n\n      v.event.add(this, \"beforeactivate._change\", function (e) {\n        var t = e.target;\n        $.test(t.nodeName) && !v._data(t, \"_change_attached\") && (v.event.add(t, \"change._change\", function (e) {\n          this.parentNode && !e.isSimulated && !e.isTrigger && v.event.simulate(\"change\", this.parentNode, e, !0);\n        }), v._data(t, \"_change_attached\", !0));\n      });\n    },\n    handle: function (e) {\n      var t = e.target;\n      if (this !== t || e.isSimulated || e.isTrigger || t.type !== \"radio\" && t.type !== \"checkbox\") return e.handleObj.handler.apply(this, arguments);\n    },\n    teardown: function () {\n      return v.event.remove(this, \"._change\"), !$.test(this.nodeName);\n    }\n  }), v.support.focusinBubbles || v.each({\n    focus: \"focusin\",\n    blur: \"focusout\"\n  }, function (e, t) {\n    var n = 0,\n        r = function (e) {\n      v.event.simulate(t, e.target, v.event.fix(e), !0);\n    };\n\n    v.event.special[t] = {\n      setup: function () {\n        n++ === 0 && i.addEventListener(e, r, !0);\n      },\n      teardown: function () {\n        --n === 0 && i.removeEventListener(e, r, !0);\n      }\n    };\n  }), v.fn.extend({\n    on: function (e, n, r, i, s) {\n      var o, u;\n\n      if (typeof e == \"object\") {\n        typeof n != \"string\" && (r = r || n, n = t);\n\n        for (u in e) this.on(u, n, r, e[u], s);\n\n        return this;\n      }\n\n      r == null && i == null ? (i = n, r = n = t) : i == null && (typeof n == \"string\" ? (i = r, r = t) : (i = r, r = n, n = t));\n      if (i === !1) i = et;else if (!i) return this;\n      return s === 1 && (o = i, i = function (e) {\n        return v().off(e), o.apply(this, arguments);\n      }, i.guid = o.guid || (o.guid = v.guid++)), this.each(function () {\n        v.event.add(this, e, i, r, n);\n      });\n    },\n    one: function (e, t, n, r) {\n      return this.on(e, t, n, r, 1);\n    },\n    off: function (e, n, r) {\n      var i, s;\n      if (e && e.preventDefault && e.handleObj) return i = e.handleObj, v(e.delegateTarget).off(i.namespace ? i.origType + \".\" + i.namespace : i.origType, i.selector, i.handler), this;\n\n      if (typeof e == \"object\") {\n        for (s in e) this.off(s, n, e[s]);\n\n        return this;\n      }\n\n      if (n === !1 || typeof n == \"function\") r = n, n = t;\n      return r === !1 && (r = et), this.each(function () {\n        v.event.remove(this, e, r, n);\n      });\n    },\n    bind: function (e, t, n) {\n      return this.on(e, null, t, n);\n    },\n    unbind: function (e, t) {\n      return this.off(e, null, t);\n    },\n    live: function (e, t, n) {\n      return v(this.context).on(e, this.selector, t, n), this;\n    },\n    die: function (e, t) {\n      return v(this.context).off(e, this.selector || \"**\", t), this;\n    },\n    delegate: function (e, t, n, r) {\n      return this.on(t, e, n, r);\n    },\n    undelegate: function (e, t, n) {\n      return arguments.length === 1 ? this.off(e, \"**\") : this.off(t, e || \"**\", n);\n    },\n    trigger: function (e, t) {\n      return this.each(function () {\n        v.event.trigger(e, t, this);\n      });\n    },\n    triggerHandler: function (e, t) {\n      if (this[0]) return v.event.trigger(e, t, this[0], !0);\n    },\n    toggle: function (e) {\n      var t = arguments,\n          n = e.guid || v.guid++,\n          r = 0,\n          i = function (n) {\n        var i = (v._data(this, \"lastToggle\" + e.guid) || 0) % r;\n        return v._data(this, \"lastToggle\" + e.guid, i + 1), n.preventDefault(), t[i].apply(this, arguments) || !1;\n      };\n\n      i.guid = n;\n\n      while (r < t.length) t[r++].guid = n;\n\n      return this.click(i);\n    },\n    hover: function (e, t) {\n      return this.mouseenter(e).mouseleave(t || e);\n    }\n  }), v.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (e, t) {\n    v.fn[t] = function (e, n) {\n      return n == null && (n = e, e = null), arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);\n    }, Q.test(t) && (v.event.fixHooks[t] = v.event.keyHooks), G.test(t) && (v.event.fixHooks[t] = v.event.mouseHooks);\n  }), function (e, t) {\n    function nt(e, t, n, r) {\n      n = n || [], t = t || g;\n      var i,\n          s,\n          a,\n          f,\n          l = t.nodeType;\n      if (!e || typeof e != \"string\") return n;\n      if (l !== 1 && l !== 9) return [];\n      a = o(t);\n      if (!a && !r) if (i = R.exec(e)) if (f = i[1]) {\n        if (l === 9) {\n          s = t.getElementById(f);\n          if (!s || !s.parentNode) return n;\n          if (s.id === f) return n.push(s), n;\n        } else if (t.ownerDocument && (s = t.ownerDocument.getElementById(f)) && u(t, s) && s.id === f) return n.push(s), n;\n      } else {\n        if (i[2]) return S.apply(n, x.call(t.getElementsByTagName(e), 0)), n;\n        if ((f = i[3]) && Z && t.getElementsByClassName) return S.apply(n, x.call(t.getElementsByClassName(f), 0)), n;\n      }\n      return vt(e.replace(j, \"$1\"), t, n, r, a);\n    }\n\n    function rt(e) {\n      return function (t) {\n        var n = t.nodeName.toLowerCase();\n        return n === \"input\" && t.type === e;\n      };\n    }\n\n    function it(e) {\n      return function (t) {\n        var n = t.nodeName.toLowerCase();\n        return (n === \"input\" || n === \"button\") && t.type === e;\n      };\n    }\n\n    function st(e) {\n      return N(function (t) {\n        return t = +t, N(function (n, r) {\n          var i,\n              s = e([], n.length, t),\n              o = s.length;\n\n          while (o--) n[i = s[o]] && (n[i] = !(r[i] = n[i]));\n        });\n      });\n    }\n\n    function ot(e, t, n) {\n      if (e === t) return n;\n      var r = e.nextSibling;\n\n      while (r) {\n        if (r === t) return -1;\n        r = r.nextSibling;\n      }\n\n      return 1;\n    }\n\n    function ut(e, t) {\n      var n,\n          r,\n          s,\n          o,\n          u,\n          a,\n          f,\n          l = L[d][e + \" \"];\n      if (l) return t ? 0 : l.slice(0);\n      u = e, a = [], f = i.preFilter;\n\n      while (u) {\n        if (!n || (r = F.exec(u))) r && (u = u.slice(r[0].length) || u), a.push(s = []);\n        n = !1;\n        if (r = I.exec(u)) s.push(n = new m(r.shift())), u = u.slice(n.length), n.type = r[0].replace(j, \" \");\n\n        for (o in i.filter) (r = J[o].exec(u)) && (!f[o] || (r = f[o](r))) && (s.push(n = new m(r.shift())), u = u.slice(n.length), n.type = o, n.matches = r);\n\n        if (!n) break;\n      }\n\n      return t ? u.length : u ? nt.error(e) : L(e, a).slice(0);\n    }\n\n    function at(e, t, r) {\n      var i = t.dir,\n          s = r && t.dir === \"parentNode\",\n          o = w++;\n      return t.first ? function (t, n, r) {\n        while (t = t[i]) if (s || t.nodeType === 1) return e(t, n, r);\n      } : function (t, r, u) {\n        if (!u) {\n          var a,\n              f = b + \" \" + o + \" \",\n              l = f + n;\n\n          while (t = t[i]) if (s || t.nodeType === 1) {\n            if ((a = t[d]) === l) return t.sizset;\n\n            if (typeof a == \"string\" && a.indexOf(f) === 0) {\n              if (t.sizset) return t;\n            } else {\n              t[d] = l;\n              if (e(t, r, u)) return t.sizset = !0, t;\n              t.sizset = !1;\n            }\n          }\n        } else while (t = t[i]) if (s || t.nodeType === 1) if (e(t, r, u)) return t;\n      };\n    }\n\n    function ft(e) {\n      return e.length > 1 ? function (t, n, r) {\n        var i = e.length;\n\n        while (i--) if (!e[i](t, n, r)) return !1;\n\n        return !0;\n      } : e[0];\n    }\n\n    function lt(e, t, n, r, i) {\n      var s,\n          o = [],\n          u = 0,\n          a = e.length,\n          f = t != null;\n\n      for (; u < a; u++) if (s = e[u]) if (!n || n(s, r, i)) o.push(s), f && t.push(u);\n\n      return o;\n    }\n\n    function ct(e, t, n, r, i, s) {\n      return r && !r[d] && (r = ct(r)), i && !i[d] && (i = ct(i, s)), N(function (s, o, u, a) {\n        var f,\n            l,\n            c,\n            h = [],\n            p = [],\n            d = o.length,\n            v = s || dt(t || \"*\", u.nodeType ? [u] : u, []),\n            m = e && (s || !t) ? lt(v, h, e, u, a) : v,\n            g = n ? i || (s ? e : d || r) ? [] : o : m;\n        n && n(m, g, u, a);\n\n        if (r) {\n          f = lt(g, p), r(f, [], u, a), l = f.length;\n\n          while (l--) if (c = f[l]) g[p[l]] = !(m[p[l]] = c);\n        }\n\n        if (s) {\n          if (i || e) {\n            if (i) {\n              f = [], l = g.length;\n\n              while (l--) (c = g[l]) && f.push(m[l] = c);\n\n              i(null, g = [], f, a);\n            }\n\n            l = g.length;\n\n            while (l--) (c = g[l]) && (f = i ? T.call(s, c) : h[l]) > -1 && (s[f] = !(o[f] = c));\n          }\n        } else g = lt(g === o ? g.splice(d, g.length) : g), i ? i(null, o, g, a) : S.apply(o, g);\n      });\n    }\n\n    function ht(e) {\n      var t,\n          n,\n          r,\n          s = e.length,\n          o = i.relative[e[0].type],\n          u = o || i.relative[\" \"],\n          a = o ? 1 : 0,\n          f = at(function (e) {\n        return e === t;\n      }, u, !0),\n          l = at(function (e) {\n        return T.call(t, e) > -1;\n      }, u, !0),\n          h = [function (e, n, r) {\n        return !o && (r || n !== c) || ((t = n).nodeType ? f(e, n, r) : l(e, n, r));\n      }];\n\n      for (; a < s; a++) if (n = i.relative[e[a].type]) h = [at(ft(h), n)];else {\n        n = i.filter[e[a].type].apply(null, e[a].matches);\n\n        if (n[d]) {\n          r = ++a;\n\n          for (; r < s; r++) if (i.relative[e[r].type]) break;\n\n          return ct(a > 1 && ft(h), a > 1 && e.slice(0, a - 1).join(\"\").replace(j, \"$1\"), n, a < r && ht(e.slice(a, r)), r < s && ht(e = e.slice(r)), r < s && e.join(\"\"));\n        }\n\n        h.push(n);\n      }\n\n      return ft(h);\n    }\n\n    function pt(e, t) {\n      var r = t.length > 0,\n          s = e.length > 0,\n          o = function (u, a, f, l, h) {\n        var p,\n            d,\n            v,\n            m = [],\n            y = 0,\n            w = \"0\",\n            x = u && [],\n            T = h != null,\n            N = c,\n            C = u || s && i.find.TAG(\"*\", h && a.parentNode || a),\n            k = b += N == null ? 1 : Math.E;\n        T && (c = a !== g && a, n = o.el);\n\n        for (; (p = C[w]) != null; w++) {\n          if (s && p) {\n            for (d = 0; v = e[d]; d++) if (v(p, a, f)) {\n              l.push(p);\n              break;\n            }\n\n            T && (b = k, n = ++o.el);\n          }\n\n          r && ((p = !v && p) && y--, u && x.push(p));\n        }\n\n        y += w;\n\n        if (r && w !== y) {\n          for (d = 0; v = t[d]; d++) v(x, m, a, f);\n\n          if (u) {\n            if (y > 0) while (w--) !x[w] && !m[w] && (m[w] = E.call(l));\n            m = lt(m);\n          }\n\n          S.apply(l, m), T && !u && m.length > 0 && y + t.length > 1 && nt.uniqueSort(l);\n        }\n\n        return T && (b = k, c = N), x;\n      };\n\n      return o.el = 0, r ? N(o) : o;\n    }\n\n    function dt(e, t, n) {\n      var r = 0,\n          i = t.length;\n\n      for (; r < i; r++) nt(e, t[r], n);\n\n      return n;\n    }\n\n    function vt(e, t, n, r, s) {\n      var o,\n          u,\n          f,\n          l,\n          c,\n          h = ut(e),\n          p = h.length;\n\n      if (!r && h.length === 1) {\n        u = h[0] = h[0].slice(0);\n\n        if (u.length > 2 && (f = u[0]).type === \"ID\" && t.nodeType === 9 && !s && i.relative[u[1].type]) {\n          t = i.find.ID(f.matches[0].replace($, \"\"), t, s)[0];\n          if (!t) return n;\n          e = e.slice(u.shift().length);\n        }\n\n        for (o = J.POS.test(e) ? -1 : u.length - 1; o >= 0; o--) {\n          f = u[o];\n          if (i.relative[l = f.type]) break;\n          if (c = i.find[l]) if (r = c(f.matches[0].replace($, \"\"), z.test(u[0].type) && t.parentNode || t, s)) {\n            u.splice(o, 1), e = r.length && u.join(\"\");\n            if (!e) return S.apply(n, x.call(r, 0)), n;\n            break;\n          }\n        }\n      }\n\n      return a(e, h)(r, t, s, n, z.test(e)), n;\n    }\n\n    function mt() {}\n\n    var n,\n        r,\n        i,\n        s,\n        o,\n        u,\n        a,\n        f,\n        l,\n        c,\n        h = !0,\n        p = \"undefined\",\n        d = (\"sizcache\" + Math.random()).replace(\".\", \"\"),\n        m = String,\n        g = e.document,\n        y = g.documentElement,\n        b = 0,\n        w = 0,\n        E = [].pop,\n        S = [].push,\n        x = [].slice,\n        T = [].indexOf || function (e) {\n      var t = 0,\n          n = this.length;\n\n      for (; t < n; t++) if (this[t] === e) return t;\n\n      return -1;\n    },\n        N = function (e, t) {\n      return e[d] = t == null || t, e;\n    },\n        C = function () {\n      var e = {},\n          t = [];\n      return N(function (n, r) {\n        return t.push(n) > i.cacheLength && delete e[t.shift()], e[n + \" \"] = r;\n      }, e);\n    },\n        k = C(),\n        L = C(),\n        A = C(),\n        O = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        M = \"(?:\\\\\\\\.|[-\\\\w]|[^\\\\x00-\\\\xa0])+\",\n        _ = M.replace(\"w\", \"w#\"),\n        D = \"([*^$|!~]?=)\",\n        P = \"\\\\[\" + O + \"*(\" + M + \")\" + O + \"*(?:\" + D + O + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + _ + \")|)|)\" + O + \"*\\\\]\",\n        H = \":(\" + M + \")(?:\\\\((?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\2|([^()[\\\\]]*|(?:(?:\" + P + \")|[^:]|\\\\\\\\.)*|.*))\\\\)|)\",\n        B = \":(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + O + \"*((?:-\\\\d)?\\\\d*)\" + O + \"*\\\\)|)(?=[^-]|$)\",\n        j = new RegExp(\"^\" + O + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + O + \"+$\", \"g\"),\n        F = new RegExp(\"^\" + O + \"*,\" + O + \"*\"),\n        I = new RegExp(\"^\" + O + \"*([\\\\x20\\\\t\\\\r\\\\n\\\\f>+~])\" + O + \"*\"),\n        q = new RegExp(H),\n        R = /^(?:#([\\w\\-]+)|(\\w+)|\\.([\\w\\-]+))$/,\n        U = /^:not/,\n        z = /[\\x20\\t\\r\\n\\f]*[+~]/,\n        W = /:not\\($/,\n        X = /h\\d/i,\n        V = /input|select|textarea|button/i,\n        $ = /\\\\(?!\\\\)/g,\n        J = {\n      ID: new RegExp(\"^#(\" + M + \")\"),\n      CLASS: new RegExp(\"^\\\\.(\" + M + \")\"),\n      NAME: new RegExp(\"^\\\\[name=['\\\"]?(\" + M + \")['\\\"]?\\\\]\"),\n      TAG: new RegExp(\"^(\" + M.replace(\"w\", \"w*\") + \")\"),\n      ATTR: new RegExp(\"^\" + P),\n      PSEUDO: new RegExp(\"^\" + H),\n      POS: new RegExp(B, \"i\"),\n      CHILD: new RegExp(\"^:(only|nth|first|last)-child(?:\\\\(\" + O + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + O + \"*(?:([+-]|)\" + O + \"*(\\\\d+)|))\" + O + \"*\\\\)|)\", \"i\"),\n      needsContext: new RegExp(\"^\" + O + \"*[>+~]|\" + B, \"i\")\n    },\n        K = function (e) {\n      var t = g.createElement(\"div\");\n\n      try {\n        return e(t);\n      } catch (n) {\n        return !1;\n      } finally {\n        t = null;\n      }\n    },\n        Q = K(function (e) {\n      return e.appendChild(g.createComment(\"\")), !e.getElementsByTagName(\"*\").length;\n    }),\n        G = K(function (e) {\n      return e.innerHTML = \"<a href='#'></a>\", e.firstChild && typeof e.firstChild.getAttribute !== p && e.firstChild.getAttribute(\"href\") === \"#\";\n    }),\n        Y = K(function (e) {\n      e.innerHTML = \"<select></select>\";\n      var t = typeof e.lastChild.getAttribute(\"multiple\");\n      return t !== \"boolean\" && t !== \"string\";\n    }),\n        Z = K(function (e) {\n      return e.innerHTML = \"<div class='hidden e'></div><div class='hidden'></div>\", !e.getElementsByClassName || !e.getElementsByClassName(\"e\").length ? !1 : (e.lastChild.className = \"e\", e.getElementsByClassName(\"e\").length === 2);\n    }),\n        et = K(function (e) {\n      e.id = d + 0, e.innerHTML = \"<a name='\" + d + \"'></a><div name='\" + d + \"'></div>\", y.insertBefore(e, y.firstChild);\n      var t = g.getElementsByName && g.getElementsByName(d).length === 2 + g.getElementsByName(d + 0).length;\n      return r = !g.getElementById(d), y.removeChild(e), t;\n    });\n\n    try {\n      x.call(y.childNodes, 0)[0].nodeType;\n    } catch (tt) {\n      x = function (e) {\n        var t,\n            n = [];\n\n        for (; t = this[e]; e++) n.push(t);\n\n        return n;\n      };\n    }\n\n    nt.matches = function (e, t) {\n      return nt(e, null, null, t);\n    }, nt.matchesSelector = function (e, t) {\n      return nt(t, null, null, [e]).length > 0;\n    }, s = nt.getText = function (e) {\n      var t,\n          n = \"\",\n          r = 0,\n          i = e.nodeType;\n\n      if (i) {\n        if (i === 1 || i === 9 || i === 11) {\n          if (typeof e.textContent == \"string\") return e.textContent;\n\n          for (e = e.firstChild; e; e = e.nextSibling) n += s(e);\n        } else if (i === 3 || i === 4) return e.nodeValue;\n      } else for (; t = e[r]; r++) n += s(t);\n\n      return n;\n    }, o = nt.isXML = function (e) {\n      var t = e && (e.ownerDocument || e).documentElement;\n      return t ? t.nodeName !== \"HTML\" : !1;\n    }, u = nt.contains = y.contains ? function (e, t) {\n      var n = e.nodeType === 9 ? e.documentElement : e,\n          r = t && t.parentNode;\n      return e === r || !!(r && r.nodeType === 1 && n.contains && n.contains(r));\n    } : y.compareDocumentPosition ? function (e, t) {\n      return t && !!(e.compareDocumentPosition(t) & 16);\n    } : function (e, t) {\n      while (t = t.parentNode) if (t === e) return !0;\n\n      return !1;\n    }, nt.attr = function (e, t) {\n      var n,\n          r = o(e);\n      return r || (t = t.toLowerCase()), (n = i.attrHandle[t]) ? n(e) : r || Y ? e.getAttribute(t) : (n = e.getAttributeNode(t), n ? typeof e[t] == \"boolean\" ? e[t] ? t : null : n.specified ? n.value : null : null);\n    }, i = nt.selectors = {\n      cacheLength: 50,\n      createPseudo: N,\n      match: J,\n      attrHandle: G ? {} : {\n        href: function (e) {\n          return e.getAttribute(\"href\", 2);\n        },\n        type: function (e) {\n          return e.getAttribute(\"type\");\n        }\n      },\n      find: {\n        ID: r ? function (e, t, n) {\n          if (typeof t.getElementById !== p && !n) {\n            var r = t.getElementById(e);\n            return r && r.parentNode ? [r] : [];\n          }\n        } : function (e, n, r) {\n          if (typeof n.getElementById !== p && !r) {\n            var i = n.getElementById(e);\n            return i ? i.id === e || typeof i.getAttributeNode !== p && i.getAttributeNode(\"id\").value === e ? [i] : t : [];\n          }\n        },\n        TAG: Q ? function (e, t) {\n          if (typeof t.getElementsByTagName !== p) return t.getElementsByTagName(e);\n        } : function (e, t) {\n          var n = t.getElementsByTagName(e);\n\n          if (e === \"*\") {\n            var r,\n                i = [],\n                s = 0;\n\n            for (; r = n[s]; s++) r.nodeType === 1 && i.push(r);\n\n            return i;\n          }\n\n          return n;\n        },\n        NAME: et && function (e, t) {\n          if (typeof t.getElementsByName !== p) return t.getElementsByName(name);\n        },\n        CLASS: Z && function (e, t, n) {\n          if (typeof t.getElementsByClassName !== p && !n) return t.getElementsByClassName(e);\n        }\n      },\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: !0\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: !0\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        ATTR: function (e) {\n          return e[1] = e[1].replace($, \"\"), e[3] = (e[4] || e[5] || \"\").replace($, \"\"), e[2] === \"~=\" && (e[3] = \" \" + e[3] + \" \"), e.slice(0, 4);\n        },\n        CHILD: function (e) {\n          return e[1] = e[1].toLowerCase(), e[1] === \"nth\" ? (e[2] || nt.error(e[0]), e[3] = +(e[3] ? e[4] + (e[5] || 1) : 2 * (e[2] === \"even\" || e[2] === \"odd\")), e[4] = +(e[6] + e[7] || e[2] === \"odd\")) : e[2] && nt.error(e[0]), e;\n        },\n        PSEUDO: function (e) {\n          var t, n;\n          if (J.CHILD.test(e[0])) return null;\n          if (e[3]) e[2] = e[3];else if (t = e[4]) q.test(t) && (n = ut(t, !0)) && (n = t.indexOf(\")\", t.length - n) - t.length) && (t = t.slice(0, n), e[0] = e[0].slice(0, n)), e[2] = t;\n          return e.slice(0, 3);\n        }\n      },\n      filter: {\n        ID: r ? function (e) {\n          return e = e.replace($, \"\"), function (t) {\n            return t.getAttribute(\"id\") === e;\n          };\n        } : function (e) {\n          return e = e.replace($, \"\"), function (t) {\n            var n = typeof t.getAttributeNode !== p && t.getAttributeNode(\"id\");\n            return n && n.value === e;\n          };\n        },\n        TAG: function (e) {\n          return e === \"*\" ? function () {\n            return !0;\n          } : (e = e.replace($, \"\").toLowerCase(), function (t) {\n            return t.nodeName && t.nodeName.toLowerCase() === e;\n          });\n        },\n        CLASS: function (e) {\n          var t = k[d][e + \" \"];\n          return t || (t = new RegExp(\"(^|\" + O + \")\" + e + \"(\" + O + \"|$)\")) && k(e, function (e) {\n            return t.test(e.className || typeof e.getAttribute !== p && e.getAttribute(\"class\") || \"\");\n          });\n        },\n        ATTR: function (e, t, n) {\n          return function (r, i) {\n            var s = nt.attr(r, e);\n            return s == null ? t === \"!=\" : t ? (s += \"\", t === \"=\" ? s === n : t === \"!=\" ? s !== n : t === \"^=\" ? n && s.indexOf(n) === 0 : t === \"*=\" ? n && s.indexOf(n) > -1 : t === \"$=\" ? n && s.substr(s.length - n.length) === n : t === \"~=\" ? (\" \" + s + \" \").indexOf(n) > -1 : t === \"|=\" ? s === n || s.substr(0, n.length + 1) === n + \"-\" : !1) : !0;\n          };\n        },\n        CHILD: function (e, t, n, r) {\n          return e === \"nth\" ? function (e) {\n            var t,\n                i,\n                s = e.parentNode;\n            if (n === 1 && r === 0) return !0;\n\n            if (s) {\n              i = 0;\n\n              for (t = s.firstChild; t; t = t.nextSibling) if (t.nodeType === 1) {\n                i++;\n                if (e === t) break;\n              }\n            }\n\n            return i -= r, i === n || i % n === 0 && i / n >= 0;\n          } : function (t) {\n            var n = t;\n\n            switch (e) {\n              case \"only\":\n              case \"first\":\n                while (n = n.previousSibling) if (n.nodeType === 1) return !1;\n\n                if (e === \"first\") return !0;\n                n = t;\n\n              case \"last\":\n                while (n = n.nextSibling) if (n.nodeType === 1) return !1;\n\n                return !0;\n            }\n          };\n        },\n        PSEUDO: function (e, t) {\n          var n,\n              r = i.pseudos[e] || i.setFilters[e.toLowerCase()] || nt.error(\"unsupported pseudo: \" + e);\n          return r[d] ? r(t) : r.length > 1 ? (n = [e, e, \"\", t], i.setFilters.hasOwnProperty(e.toLowerCase()) ? N(function (e, n) {\n            var i,\n                s = r(e, t),\n                o = s.length;\n\n            while (o--) i = T.call(e, s[o]), e[i] = !(n[i] = s[o]);\n          }) : function (e) {\n            return r(e, 0, n);\n          }) : r;\n        }\n      },\n      pseudos: {\n        not: N(function (e) {\n          var t = [],\n              n = [],\n              r = a(e.replace(j, \"$1\"));\n          return r[d] ? N(function (e, t, n, i) {\n            var s,\n                o = r(e, null, i, []),\n                u = e.length;\n\n            while (u--) if (s = o[u]) e[u] = !(t[u] = s);\n          }) : function (e, i, s) {\n            return t[0] = e, r(t, null, s, n), !n.pop();\n          };\n        }),\n        has: N(function (e) {\n          return function (t) {\n            return nt(e, t).length > 0;\n          };\n        }),\n        contains: N(function (e) {\n          return function (t) {\n            return (t.textContent || t.innerText || s(t)).indexOf(e) > -1;\n          };\n        }),\n        enabled: function (e) {\n          return e.disabled === !1;\n        },\n        disabled: function (e) {\n          return e.disabled === !0;\n        },\n        checked: function (e) {\n          var t = e.nodeName.toLowerCase();\n          return t === \"input\" && !!e.checked || t === \"option\" && !!e.selected;\n        },\n        selected: function (e) {\n          return e.parentNode && e.parentNode.selectedIndex, e.selected === !0;\n        },\n        parent: function (e) {\n          return !i.pseudos.empty(e);\n        },\n        empty: function (e) {\n          var t;\n          e = e.firstChild;\n\n          while (e) {\n            if (e.nodeName > \"@\" || (t = e.nodeType) === 3 || t === 4) return !1;\n            e = e.nextSibling;\n          }\n\n          return !0;\n        },\n        header: function (e) {\n          return X.test(e.nodeName);\n        },\n        text: function (e) {\n          var t, n;\n          return e.nodeName.toLowerCase() === \"input\" && (t = e.type) === \"text\" && ((n = e.getAttribute(\"type\")) == null || n.toLowerCase() === t);\n        },\n        radio: rt(\"radio\"),\n        checkbox: rt(\"checkbox\"),\n        file: rt(\"file\"),\n        password: rt(\"password\"),\n        image: rt(\"image\"),\n        submit: it(\"submit\"),\n        reset: it(\"reset\"),\n        button: function (e) {\n          var t = e.nodeName.toLowerCase();\n          return t === \"input\" && e.type === \"button\" || t === \"button\";\n        },\n        input: function (e) {\n          return V.test(e.nodeName);\n        },\n        focus: function (e) {\n          var t = e.ownerDocument;\n          return e === t.activeElement && (!t.hasFocus || t.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);\n        },\n        active: function (e) {\n          return e === e.ownerDocument.activeElement;\n        },\n        first: st(function () {\n          return [0];\n        }),\n        last: st(function (e, t) {\n          return [t - 1];\n        }),\n        eq: st(function (e, t, n) {\n          return [n < 0 ? n + t : n];\n        }),\n        even: st(function (e, t) {\n          for (var n = 0; n < t; n += 2) e.push(n);\n\n          return e;\n        }),\n        odd: st(function (e, t) {\n          for (var n = 1; n < t; n += 2) e.push(n);\n\n          return e;\n        }),\n        lt: st(function (e, t, n) {\n          for (var r = n < 0 ? n + t : n; --r >= 0;) e.push(r);\n\n          return e;\n        }),\n        gt: st(function (e, t, n) {\n          for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);\n\n          return e;\n        })\n      }\n    }, f = y.compareDocumentPosition ? function (e, t) {\n      return e === t ? (l = !0, 0) : (!e.compareDocumentPosition || !t.compareDocumentPosition ? e.compareDocumentPosition : e.compareDocumentPosition(t) & 4) ? -1 : 1;\n    } : function (e, t) {\n      if (e === t) return l = !0, 0;\n      if (e.sourceIndex && t.sourceIndex) return e.sourceIndex - t.sourceIndex;\n      var n,\n          r,\n          i = [],\n          s = [],\n          o = e.parentNode,\n          u = t.parentNode,\n          a = o;\n      if (o === u) return ot(e, t);\n      if (!o) return -1;\n      if (!u) return 1;\n\n      while (a) i.unshift(a), a = a.parentNode;\n\n      a = u;\n\n      while (a) s.unshift(a), a = a.parentNode;\n\n      n = i.length, r = s.length;\n\n      for (var f = 0; f < n && f < r; f++) if (i[f] !== s[f]) return ot(i[f], s[f]);\n\n      return f === n ? ot(e, s[f], -1) : ot(i[f], t, 1);\n    }, [0, 0].sort(f), h = !l, nt.uniqueSort = function (e) {\n      var t,\n          n = [],\n          r = 1,\n          i = 0;\n      l = h, e.sort(f);\n\n      if (l) {\n        for (; t = e[r]; r++) t === e[r - 1] && (i = n.push(r));\n\n        while (i--) e.splice(n[i], 1);\n      }\n\n      return e;\n    }, nt.error = function (e) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + e);\n    }, a = nt.compile = function (e, t) {\n      var n,\n          r = [],\n          i = [],\n          s = A[d][e + \" \"];\n\n      if (!s) {\n        t || (t = ut(e)), n = t.length;\n\n        while (n--) s = ht(t[n]), s[d] ? r.push(s) : i.push(s);\n\n        s = A(e, pt(i, r));\n      }\n\n      return s;\n    }, g.querySelectorAll && function () {\n      var e,\n          t = vt,\n          n = /'|\\\\/g,\n          r = /\\=[\\x20\\t\\r\\n\\f]*([^'\"\\]]*)[\\x20\\t\\r\\n\\f]*\\]/g,\n          i = [\":focus\"],\n          s = [\":active\"],\n          u = y.matchesSelector || y.mozMatchesSelector || y.webkitMatchesSelector || y.oMatchesSelector || y.msMatchesSelector;\n      K(function (e) {\n        e.innerHTML = \"<select><option selected=''></option></select>\", e.querySelectorAll(\"[selected]\").length || i.push(\"\\\\[\" + O + \"*(?:checked|disabled|ismap|multiple|readonly|selected|value)\"), e.querySelectorAll(\":checked\").length || i.push(\":checked\");\n      }), K(function (e) {\n        e.innerHTML = \"<p test=''></p>\", e.querySelectorAll(\"[test^='']\").length && i.push(\"[*^$]=\" + O + \"*(?:\\\"\\\"|'')\"), e.innerHTML = \"<input type='hidden'/>\", e.querySelectorAll(\":enabled\").length || i.push(\":enabled\", \":disabled\");\n      }), i = new RegExp(i.join(\"|\")), vt = function (e, r, s, o, u) {\n        if (!o && !u && !i.test(e)) {\n          var a,\n              f,\n              l = !0,\n              c = d,\n              h = r,\n              p = r.nodeType === 9 && e;\n\n          if (r.nodeType === 1 && r.nodeName.toLowerCase() !== \"object\") {\n            a = ut(e), (l = r.getAttribute(\"id\")) ? c = l.replace(n, \"\\\\$&\") : r.setAttribute(\"id\", c), c = \"[id='\" + c + \"'] \", f = a.length;\n\n            while (f--) a[f] = c + a[f].join(\"\");\n\n            h = z.test(e) && r.parentNode || r, p = a.join(\",\");\n          }\n\n          if (p) try {\n            return S.apply(s, x.call(h.querySelectorAll(p), 0)), s;\n          } catch (v) {} finally {\n            l || r.removeAttribute(\"id\");\n          }\n        }\n\n        return t(e, r, s, o, u);\n      }, u && (K(function (t) {\n        e = u.call(t, \"div\");\n\n        try {\n          u.call(t, \"[test!='']:sizzle\"), s.push(\"!=\", H);\n        } catch (n) {}\n      }), s = new RegExp(s.join(\"|\")), nt.matchesSelector = function (t, n) {\n        n = n.replace(r, \"='$1']\");\n        if (!o(t) && !s.test(n) && !i.test(n)) try {\n          var a = u.call(t, n);\n          if (a || e || t.document && t.document.nodeType !== 11) return a;\n        } catch (f) {}\n        return nt(n, null, null, [t]).length > 0;\n      });\n    }(), i.pseudos.nth = i.pseudos.eq, i.filters = mt.prototype = i.pseudos, i.setFilters = new mt(), nt.attr = v.attr, v.find = nt, v.expr = nt.selectors, v.expr[\":\"] = v.expr.pseudos, v.unique = nt.uniqueSort, v.text = nt.getText, v.isXMLDoc = nt.isXML, v.contains = nt.contains;\n  }(e);\n  var nt = /Until$/,\n      rt = /^(?:parents|prev(?:Until|All))/,\n      it = /^.[^:#\\[\\.,]*$/,\n      st = v.expr.match.needsContext,\n      ot = {\n    children: !0,\n    contents: !0,\n    next: !0,\n    prev: !0\n  };\n  v.fn.extend({\n    find: function (e) {\n      var t,\n          n,\n          r,\n          i,\n          s,\n          o,\n          u = this;\n      if (typeof e != \"string\") return v(e).filter(function () {\n        for (t = 0, n = u.length; t < n; t++) if (v.contains(u[t], this)) return !0;\n      });\n      o = this.pushStack(\"\", \"find\", e);\n\n      for (t = 0, n = this.length; t < n; t++) {\n        r = o.length, v.find(e, this[t], o);\n        if (t > 0) for (i = r; i < o.length; i++) for (s = 0; s < r; s++) if (o[s] === o[i]) {\n          o.splice(i--, 1);\n          break;\n        }\n      }\n\n      return o;\n    },\n    has: function (e) {\n      var t,\n          n = v(e, this),\n          r = n.length;\n      return this.filter(function () {\n        for (t = 0; t < r; t++) if (v.contains(this, n[t])) return !0;\n      });\n    },\n    not: function (e) {\n      return this.pushStack(ft(this, e, !1), \"not\", e);\n    },\n    filter: function (e) {\n      return this.pushStack(ft(this, e, !0), \"filter\", e);\n    },\n    is: function (e) {\n      return !!e && (typeof e == \"string\" ? st.test(e) ? v(e, this.context).index(this[0]) >= 0 : v.filter(e, this).length > 0 : this.filter(e).length > 0);\n    },\n    closest: function (e, t) {\n      var n,\n          r = 0,\n          i = this.length,\n          s = [],\n          o = st.test(e) || typeof e != \"string\" ? v(e, t || this.context) : 0;\n\n      for (; r < i; r++) {\n        n = this[r];\n\n        while (n && n.ownerDocument && n !== t && n.nodeType !== 11) {\n          if (o ? o.index(n) > -1 : v.find.matchesSelector(n, e)) {\n            s.push(n);\n            break;\n          }\n\n          n = n.parentNode;\n        }\n      }\n\n      return s = s.length > 1 ? v.unique(s) : s, this.pushStack(s, \"closest\", e);\n    },\n    index: function (e) {\n      return e ? typeof e == \"string\" ? v.inArray(this[0], v(e)) : v.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.prevAll().length : -1;\n    },\n    add: function (e, t) {\n      var n = typeof e == \"string\" ? v(e, t) : v.makeArray(e && e.nodeType ? [e] : e),\n          r = v.merge(this.get(), n);\n      return this.pushStack(ut(n[0]) || ut(r[0]) ? r : v.unique(r));\n    },\n    addBack: function (e) {\n      return this.add(e == null ? this.prevObject : this.prevObject.filter(e));\n    }\n  }), v.fn.andSelf = v.fn.addBack, v.each({\n    parent: function (e) {\n      var t = e.parentNode;\n      return t && t.nodeType !== 11 ? t : null;\n    },\n    parents: function (e) {\n      return v.dir(e, \"parentNode\");\n    },\n    parentsUntil: function (e, t, n) {\n      return v.dir(e, \"parentNode\", n);\n    },\n    next: function (e) {\n      return at(e, \"nextSibling\");\n    },\n    prev: function (e) {\n      return at(e, \"previousSibling\");\n    },\n    nextAll: function (e) {\n      return v.dir(e, \"nextSibling\");\n    },\n    prevAll: function (e) {\n      return v.dir(e, \"previousSibling\");\n    },\n    nextUntil: function (e, t, n) {\n      return v.dir(e, \"nextSibling\", n);\n    },\n    prevUntil: function (e, t, n) {\n      return v.dir(e, \"previousSibling\", n);\n    },\n    siblings: function (e) {\n      return v.sibling((e.parentNode || {}).firstChild, e);\n    },\n    children: function (e) {\n      return v.sibling(e.firstChild);\n    },\n    contents: function (e) {\n      return v.nodeName(e, \"iframe\") ? e.contentDocument || e.contentWindow.document : v.merge([], e.childNodes);\n    }\n  }, function (e, t) {\n    v.fn[e] = function (n, r) {\n      var i = v.map(this, t, n);\n      return nt.test(e) || (r = n), r && typeof r == \"string\" && (i = v.filter(r, i)), i = this.length > 1 && !ot[e] ? v.unique(i) : i, this.length > 1 && rt.test(e) && (i = i.reverse()), this.pushStack(i, e, l.call(arguments).join(\",\"));\n    };\n  }), v.extend({\n    filter: function (e, t, n) {\n      return n && (e = \":not(\" + e + \")\"), t.length === 1 ? v.find.matchesSelector(t[0], e) ? [t[0]] : [] : v.find.matches(e, t);\n    },\n    dir: function (e, n, r) {\n      var i = [],\n          s = e[n];\n\n      while (s && s.nodeType !== 9 && (r === t || s.nodeType !== 1 || !v(s).is(r))) s.nodeType === 1 && i.push(s), s = s[n];\n\n      return i;\n    },\n    sibling: function (e, t) {\n      var n = [];\n\n      for (; e; e = e.nextSibling) e.nodeType === 1 && e !== t && n.push(e);\n\n      return n;\n    }\n  });\n  var ct = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n      ht = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n      pt = /^\\s+/,\n      dt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n      vt = /<([\\w:]+)/,\n      mt = /<tbody/i,\n      gt = /<|&#?\\w+;/,\n      yt = /<(?:script|style|link)/i,\n      bt = /<(?:script|object|embed|option|style)/i,\n      wt = new RegExp(\"<(?:\" + ct + \")[\\\\s/>]\", \"i\"),\n      Et = /^(?:checkbox|radio)$/,\n      St = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      xt = /\\/(java|ecma)script/i,\n      Tt = /^\\s*<!(?:\\[CDATA\\[|\\-\\-)|[\\]\\-]{2}>\\s*$/g,\n      Nt = {\n    option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n    legend: [1, \"<fieldset>\", \"</fieldset>\"],\n    thead: [1, \"<table>\", \"</table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    col: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"],\n    area: [1, \"<map>\", \"</map>\"],\n    _default: [0, \"\", \"\"]\n  },\n      Ct = lt(i),\n      kt = Ct.appendChild(i.createElement(\"div\"));\n  Nt.optgroup = Nt.option, Nt.tbody = Nt.tfoot = Nt.colgroup = Nt.caption = Nt.thead, Nt.th = Nt.td, v.support.htmlSerialize || (Nt._default = [1, \"X<div>\", \"</div>\"]), v.fn.extend({\n    text: function (e) {\n      return v.access(this, function (e) {\n        return e === t ? v.text(this) : this.empty().append((this[0] && this[0].ownerDocument || i).createTextNode(e));\n      }, null, e, arguments.length);\n    },\n    wrapAll: function (e) {\n      if (v.isFunction(e)) return this.each(function (t) {\n        v(this).wrapAll(e.call(this, t));\n      });\n\n      if (this[0]) {\n        var t = v(e, this[0].ownerDocument).eq(0).clone(!0);\n        this[0].parentNode && t.insertBefore(this[0]), t.map(function () {\n          var e = this;\n\n          while (e.firstChild && e.firstChild.nodeType === 1) e = e.firstChild;\n\n          return e;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function (e) {\n      return v.isFunction(e) ? this.each(function (t) {\n        v(this).wrapInner(e.call(this, t));\n      }) : this.each(function () {\n        var t = v(this),\n            n = t.contents();\n        n.length ? n.wrapAll(e) : t.append(e);\n      });\n    },\n    wrap: function (e) {\n      var t = v.isFunction(e);\n      return this.each(function (n) {\n        v(this).wrapAll(t ? e.call(this, n) : e);\n      });\n    },\n    unwrap: function () {\n      return this.parent().each(function () {\n        v.nodeName(this, \"body\") || v(this).replaceWith(this.childNodes);\n      }).end();\n    },\n    append: function () {\n      return this.domManip(arguments, !0, function (e) {\n        (this.nodeType === 1 || this.nodeType === 11) && this.appendChild(e);\n      });\n    },\n    prepend: function () {\n      return this.domManip(arguments, !0, function (e) {\n        (this.nodeType === 1 || this.nodeType === 11) && this.insertBefore(e, this.firstChild);\n      });\n    },\n    before: function () {\n      if (!ut(this[0])) return this.domManip(arguments, !1, function (e) {\n        this.parentNode.insertBefore(e, this);\n      });\n\n      if (arguments.length) {\n        var e = v.clean(arguments);\n        return this.pushStack(v.merge(e, this), \"before\", this.selector);\n      }\n    },\n    after: function () {\n      if (!ut(this[0])) return this.domManip(arguments, !1, function (e) {\n        this.parentNode.insertBefore(e, this.nextSibling);\n      });\n\n      if (arguments.length) {\n        var e = v.clean(arguments);\n        return this.pushStack(v.merge(this, e), \"after\", this.selector);\n      }\n    },\n    remove: function (e, t) {\n      var n,\n          r = 0;\n\n      for (; (n = this[r]) != null; r++) if (!e || v.filter(e, [n]).length) !t && n.nodeType === 1 && (v.cleanData(n.getElementsByTagName(\"*\")), v.cleanData([n])), n.parentNode && n.parentNode.removeChild(n);\n\n      return this;\n    },\n    empty: function () {\n      var e,\n          t = 0;\n\n      for (; (e = this[t]) != null; t++) {\n        e.nodeType === 1 && v.cleanData(e.getElementsByTagName(\"*\"));\n\n        while (e.firstChild) e.removeChild(e.firstChild);\n      }\n\n      return this;\n    },\n    clone: function (e, t) {\n      return e = e == null ? !1 : e, t = t == null ? e : t, this.map(function () {\n        return v.clone(this, e, t);\n      });\n    },\n    html: function (e) {\n      return v.access(this, function (e) {\n        var n = this[0] || {},\n            r = 0,\n            i = this.length;\n        if (e === t) return n.nodeType === 1 ? n.innerHTML.replace(ht, \"\") : t;\n\n        if (typeof e == \"string\" && !yt.test(e) && (v.support.htmlSerialize || !wt.test(e)) && (v.support.leadingWhitespace || !pt.test(e)) && !Nt[(vt.exec(e) || [\"\", \"\"])[1].toLowerCase()]) {\n          e = e.replace(dt, \"<$1></$2>\");\n\n          try {\n            for (; r < i; r++) n = this[r] || {}, n.nodeType === 1 && (v.cleanData(n.getElementsByTagName(\"*\")), n.innerHTML = e);\n\n            n = 0;\n          } catch (s) {}\n        }\n\n        n && this.empty().append(e);\n      }, null, e, arguments.length);\n    },\n    replaceWith: function (e) {\n      return ut(this[0]) ? this.length ? this.pushStack(v(v.isFunction(e) ? e() : e), \"replaceWith\", e) : this : v.isFunction(e) ? this.each(function (t) {\n        var n = v(this),\n            r = n.html();\n        n.replaceWith(e.call(this, t, r));\n      }) : (typeof e != \"string\" && (e = v(e).detach()), this.each(function () {\n        var t = this.nextSibling,\n            n = this.parentNode;\n        v(this).remove(), t ? v(t).before(e) : v(n).append(e);\n      }));\n    },\n    detach: function (e) {\n      return this.remove(e, !0);\n    },\n    domManip: function (e, n, r) {\n      e = [].concat.apply([], e);\n      var i,\n          s,\n          o,\n          u,\n          a = 0,\n          f = e[0],\n          l = [],\n          c = this.length;\n      if (!v.support.checkClone && c > 1 && typeof f == \"string\" && St.test(f)) return this.each(function () {\n        v(this).domManip(e, n, r);\n      });\n      if (v.isFunction(f)) return this.each(function (i) {\n        var s = v(this);\n        e[0] = f.call(this, i, n ? s.html() : t), s.domManip(e, n, r);\n      });\n\n      if (this[0]) {\n        i = v.buildFragment(e, this, l), o = i.fragment, s = o.firstChild, o.childNodes.length === 1 && (o = s);\n\n        if (s) {\n          n = n && v.nodeName(s, \"tr\");\n\n          for (u = i.cacheable || c - 1; a < c; a++) r.call(n && v.nodeName(this[a], \"table\") ? Lt(this[a], \"tbody\") : this[a], a === u ? o : v.clone(o, !0, !0));\n        }\n\n        o = s = null, l.length && v.each(l, function (e, t) {\n          t.src ? v.ajax ? v.ajax({\n            url: t.src,\n            type: \"GET\",\n            dataType: \"script\",\n            async: !1,\n            global: !1,\n            \"throws\": !0\n          }) : v.error(\"no ajax\") : v.globalEval((t.text || t.textContent || t.innerHTML || \"\").replace(Tt, \"\")), t.parentNode && t.parentNode.removeChild(t);\n        });\n      }\n\n      return this;\n    }\n  }), v.buildFragment = function (e, n, r) {\n    var s,\n        o,\n        u,\n        a = e[0];\n    return n = n || i, n = !n.nodeType && n[0] || n, n = n.ownerDocument || n, e.length === 1 && typeof a == \"string\" && a.length < 512 && n === i && a.charAt(0) === \"<\" && !bt.test(a) && (v.support.checkClone || !St.test(a)) && (v.support.html5Clone || !wt.test(a)) && (o = !0, s = v.fragments[a], u = s !== t), s || (s = n.createDocumentFragment(), v.clean(e, n, s, r), o && (v.fragments[a] = u && s)), {\n      fragment: s,\n      cacheable: o\n    };\n  }, v.fragments = {}, v.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (e, t) {\n    v.fn[e] = function (n) {\n      var r,\n          i = 0,\n          s = [],\n          o = v(n),\n          u = o.length,\n          a = this.length === 1 && this[0].parentNode;\n      if ((a == null || a && a.nodeType === 11 && a.childNodes.length === 1) && u === 1) return o[t](this[0]), this;\n\n      for (; i < u; i++) r = (i > 0 ? this.clone(!0) : this).get(), v(o[i])[t](r), s = s.concat(r);\n\n      return this.pushStack(s, e, o.selector);\n    };\n  }), v.extend({\n    clone: function (e, t, n) {\n      var r, i, s, o;\n      v.support.html5Clone || v.isXMLDoc(e) || !wt.test(\"<\" + e.nodeName + \">\") ? o = e.cloneNode(!0) : (kt.innerHTML = e.outerHTML, kt.removeChild(o = kt.firstChild));\n\n      if ((!v.support.noCloneEvent || !v.support.noCloneChecked) && (e.nodeType === 1 || e.nodeType === 11) && !v.isXMLDoc(e)) {\n        Ot(e, o), r = Mt(e), i = Mt(o);\n\n        for (s = 0; r[s]; ++s) i[s] && Ot(r[s], i[s]);\n      }\n\n      if (t) {\n        At(e, o);\n\n        if (n) {\n          r = Mt(e), i = Mt(o);\n\n          for (s = 0; r[s]; ++s) At(r[s], i[s]);\n        }\n      }\n\n      return r = i = null, o;\n    },\n    clean: function (e, t, n, r) {\n      var s,\n          o,\n          u,\n          a,\n          f,\n          l,\n          c,\n          h,\n          p,\n          d,\n          m,\n          g,\n          y = t === i && Ct,\n          b = [];\n      if (!t || typeof t.createDocumentFragment == \"undefined\") t = i;\n\n      for (s = 0; (u = e[s]) != null; s++) {\n        typeof u == \"number\" && (u += \"\");\n        if (!u) continue;\n        if (typeof u == \"string\") if (!gt.test(u)) u = t.createTextNode(u);else {\n          y = y || lt(t), c = t.createElement(\"div\"), y.appendChild(c), u = u.replace(dt, \"<$1></$2>\"), a = (vt.exec(u) || [\"\", \"\"])[1].toLowerCase(), f = Nt[a] || Nt._default, l = f[0], c.innerHTML = f[1] + u + f[2];\n\n          while (l--) c = c.lastChild;\n\n          if (!v.support.tbody) {\n            h = mt.test(u), p = a === \"table\" && !h ? c.firstChild && c.firstChild.childNodes : f[1] === \"<table>\" && !h ? c.childNodes : [];\n\n            for (o = p.length - 1; o >= 0; --o) v.nodeName(p[o], \"tbody\") && !p[o].childNodes.length && p[o].parentNode.removeChild(p[o]);\n          }\n\n          !v.support.leadingWhitespace && pt.test(u) && c.insertBefore(t.createTextNode(pt.exec(u)[0]), c.firstChild), u = c.childNodes, c.parentNode.removeChild(c);\n        }\n        u.nodeType ? b.push(u) : v.merge(b, u);\n      }\n\n      c && (u = c = y = null);\n      if (!v.support.appendChecked) for (s = 0; (u = b[s]) != null; s++) v.nodeName(u, \"input\") ? _t(u) : typeof u.getElementsByTagName != \"undefined\" && v.grep(u.getElementsByTagName(\"input\"), _t);\n\n      if (n) {\n        m = function (e) {\n          if (!e.type || xt.test(e.type)) return r ? r.push(e.parentNode ? e.parentNode.removeChild(e) : e) : n.appendChild(e);\n        };\n\n        for (s = 0; (u = b[s]) != null; s++) if (!v.nodeName(u, \"script\") || !m(u)) n.appendChild(u), typeof u.getElementsByTagName != \"undefined\" && (g = v.grep(v.merge([], u.getElementsByTagName(\"script\")), m), b.splice.apply(b, [s + 1, 0].concat(g)), s += g.length);\n      }\n\n      return b;\n    },\n    cleanData: function (e, t) {\n      var n,\n          r,\n          i,\n          s,\n          o = 0,\n          u = v.expando,\n          a = v.cache,\n          f = v.support.deleteExpando,\n          l = v.event.special;\n\n      for (; (i = e[o]) != null; o++) if (t || v.acceptData(i)) {\n        r = i[u], n = r && a[r];\n\n        if (n) {\n          if (n.events) for (s in n.events) l[s] ? v.event.remove(i, s) : v.removeEvent(i, s, n.handle);\n          a[r] && (delete a[r], f ? delete i[u] : i.removeAttribute ? i.removeAttribute(u) : i[u] = null, v.deletedIds.push(r));\n        }\n      }\n    }\n  }), function () {\n    var e, t;\n    v.uaMatch = function (e) {\n      e = e.toLowerCase();\n      var t = /(chrome)[ \\/]([\\w.]+)/.exec(e) || /(webkit)[ \\/]([\\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(e) || /(msie) ([\\w.]+)/.exec(e) || e.indexOf(\"compatible\") < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(e) || [];\n      return {\n        browser: t[1] || \"\",\n        version: t[2] || \"0\"\n      };\n    }, e = v.uaMatch(o.userAgent), t = {}, e.browser && (t[e.browser] = !0, t.version = e.version), t.chrome ? t.webkit = !0 : t.webkit && (t.safari = !0), v.browser = t, v.sub = function () {\n      function e(t, n) {\n        return new e.fn.init(t, n);\n      }\n\n      v.extend(!0, e, this), e.superclass = this, e.fn = e.prototype = this(), e.fn.constructor = e, e.sub = this.sub, e.fn.init = function (r, i) {\n        return i && i instanceof v && !(i instanceof e) && (i = e(i)), v.fn.init.call(this, r, i, t);\n      }, e.fn.init.prototype = e.fn;\n      var t = e(i);\n      return e;\n    };\n  }();\n  var Dt,\n      Pt,\n      Ht,\n      Bt = /alpha\\([^)]*\\)/i,\n      jt = /opacity=([^)]*)/,\n      Ft = /^(top|right|bottom|left)$/,\n      It = /^(none|table(?!-c[ea]).+)/,\n      qt = /^margin/,\n      Rt = new RegExp(\"^(\" + m + \")(.*)$\", \"i\"),\n      Ut = new RegExp(\"^(\" + m + \")(?!px)[a-z%]+$\", \"i\"),\n      zt = new RegExp(\"^([-+])=(\" + m + \")\", \"i\"),\n      Wt = {\n    BODY: \"block\"\n  },\n      Xt = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      Vt = {\n    letterSpacing: 0,\n    fontWeight: 400\n  },\n      $t = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      Jt = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      Kt = v.fn.toggle;\n  v.fn.extend({\n    css: function (e, n) {\n      return v.access(this, function (e, n, r) {\n        return r !== t ? v.style(e, n, r) : v.css(e, n);\n      }, e, n, arguments.length > 1);\n    },\n    show: function () {\n      return Yt(this, !0);\n    },\n    hide: function () {\n      return Yt(this);\n    },\n    toggle: function (e, t) {\n      var n = typeof e == \"boolean\";\n      return v.isFunction(e) && v.isFunction(t) ? Kt.apply(this, arguments) : this.each(function () {\n        (n ? e : Gt(this)) ? v(this).show() : v(this).hide();\n      });\n    }\n  }), v.extend({\n    cssHooks: {\n      opacity: {\n        get: function (e, t) {\n          if (t) {\n            var n = Dt(e, \"opacity\");\n            return n === \"\" ? \"1\" : n;\n          }\n        }\n      }\n    },\n    cssNumber: {\n      fillOpacity: !0,\n      fontWeight: !0,\n      lineHeight: !0,\n      opacity: !0,\n      orphans: !0,\n      widows: !0,\n      zIndex: !0,\n      zoom: !0\n    },\n    cssProps: {\n      \"float\": v.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n    },\n    style: function (e, n, r, i) {\n      if (!e || e.nodeType === 3 || e.nodeType === 8 || !e.style) return;\n      var s,\n          o,\n          u,\n          a = v.camelCase(n),\n          f = e.style;\n      n = v.cssProps[a] || (v.cssProps[a] = Qt(f, a)), u = v.cssHooks[n] || v.cssHooks[a];\n      if (r === t) return u && \"get\" in u && (s = u.get(e, !1, i)) !== t ? s : f[n];\n      o = typeof r, o === \"string\" && (s = zt.exec(r)) && (r = (s[1] + 1) * s[2] + parseFloat(v.css(e, n)), o = \"number\");\n      if (r == null || o === \"number\" && isNaN(r)) return;\n      o === \"number\" && !v.cssNumber[a] && (r += \"px\");\n      if (!u || !(\"set\" in u) || (r = u.set(e, r, i)) !== t) try {\n        f[n] = r;\n      } catch (l) {}\n    },\n    css: function (e, n, r, i) {\n      var s,\n          o,\n          u,\n          a = v.camelCase(n);\n      return n = v.cssProps[a] || (v.cssProps[a] = Qt(e.style, a)), u = v.cssHooks[n] || v.cssHooks[a], u && \"get\" in u && (s = u.get(e, !0, i)), s === t && (s = Dt(e, n)), s === \"normal\" && n in Vt && (s = Vt[n]), r || i !== t ? (o = parseFloat(s), r || v.isNumeric(o) ? o || 0 : s) : s;\n    },\n    swap: function (e, t, n) {\n      var r,\n          i,\n          s = {};\n\n      for (i in t) s[i] = e.style[i], e.style[i] = t[i];\n\n      r = n.call(e);\n\n      for (i in t) e.style[i] = s[i];\n\n      return r;\n    }\n  }), e.getComputedStyle ? Dt = function (t, n) {\n    var r,\n        i,\n        s,\n        o,\n        u = e.getComputedStyle(t, null),\n        a = t.style;\n    return u && (r = u.getPropertyValue(n) || u[n], r === \"\" && !v.contains(t.ownerDocument, t) && (r = v.style(t, n)), Ut.test(r) && qt.test(n) && (i = a.width, s = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = r, r = u.width, a.width = i, a.minWidth = s, a.maxWidth = o)), r;\n  } : i.documentElement.currentStyle && (Dt = function (e, t) {\n    var n,\n        r,\n        i = e.currentStyle && e.currentStyle[t],\n        s = e.style;\n    return i == null && s && s[t] && (i = s[t]), Ut.test(i) && !Ft.test(t) && (n = s.left, r = e.runtimeStyle && e.runtimeStyle.left, r && (e.runtimeStyle.left = e.currentStyle.left), s.left = t === \"fontSize\" ? \"1em\" : i, i = s.pixelLeft + \"px\", s.left = n, r && (e.runtimeStyle.left = r)), i === \"\" ? \"auto\" : i;\n  }), v.each([\"height\", \"width\"], function (e, t) {\n    v.cssHooks[t] = {\n      get: function (e, n, r) {\n        if (n) return e.offsetWidth === 0 && It.test(Dt(e, \"display\")) ? v.swap(e, Xt, function () {\n          return tn(e, t, r);\n        }) : tn(e, t, r);\n      },\n      set: function (e, n, r) {\n        return Zt(e, n, r ? en(e, t, r, v.support.boxSizing && v.css(e, \"boxSizing\") === \"border-box\") : 0);\n      }\n    };\n  }), v.support.opacity || (v.cssHooks.opacity = {\n    get: function (e, t) {\n      return jt.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || \"\") ? .01 * parseFloat(RegExp.$1) + \"\" : t ? \"1\" : \"\";\n    },\n    set: function (e, t) {\n      var n = e.style,\n          r = e.currentStyle,\n          i = v.isNumeric(t) ? \"alpha(opacity=\" + t * 100 + \")\" : \"\",\n          s = r && r.filter || n.filter || \"\";\n      n.zoom = 1;\n\n      if (t >= 1 && v.trim(s.replace(Bt, \"\")) === \"\" && n.removeAttribute) {\n        n.removeAttribute(\"filter\");\n        if (r && !r.filter) return;\n      }\n\n      n.filter = Bt.test(s) ? s.replace(Bt, i) : s + \" \" + i;\n    }\n  }), v(function () {\n    v.support.reliableMarginRight || (v.cssHooks.marginRight = {\n      get: function (e, t) {\n        return v.swap(e, {\n          display: \"inline-block\"\n        }, function () {\n          if (t) return Dt(e, \"marginRight\");\n        });\n      }\n    }), !v.support.pixelPosition && v.fn.position && v.each([\"top\", \"left\"], function (e, t) {\n      v.cssHooks[t] = {\n        get: function (e, n) {\n          if (n) {\n            var r = Dt(e, t);\n            return Ut.test(r) ? v(e).position()[t] + \"px\" : r;\n          }\n        }\n      };\n    });\n  }), v.expr && v.expr.filters && (v.expr.filters.hidden = function (e) {\n    return e.offsetWidth === 0 && e.offsetHeight === 0 || !v.support.reliableHiddenOffsets && (e.style && e.style.display || Dt(e, \"display\")) === \"none\";\n  }, v.expr.filters.visible = function (e) {\n    return !v.expr.filters.hidden(e);\n  }), v.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (e, t) {\n    v.cssHooks[e + t] = {\n      expand: function (n) {\n        var r,\n            i = typeof n == \"string\" ? n.split(\" \") : [n],\n            s = {};\n\n        for (r = 0; r < 4; r++) s[e + $t[r] + t] = i[r] || i[r - 2] || i[0];\n\n        return s;\n      }\n    }, qt.test(e) || (v.cssHooks[e + t].set = Zt);\n  });\n  var rn = /%20/g,\n      sn = /\\[\\]$/,\n      on = /\\r?\\n/g,\n      un = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,\n      an = /^(?:select|textarea)/i;\n  v.fn.extend({\n    serialize: function () {\n      return v.param(this.serializeArray());\n    },\n    serializeArray: function () {\n      return this.map(function () {\n        return this.elements ? v.makeArray(this.elements) : this;\n      }).filter(function () {\n        return this.name && !this.disabled && (this.checked || an.test(this.nodeName) || un.test(this.type));\n      }).map(function (e, t) {\n        var n = v(this).val();\n        return n == null ? null : v.isArray(n) ? v.map(n, function (e, n) {\n          return {\n            name: t.name,\n            value: e.replace(on, \"\\r\\n\")\n          };\n        }) : {\n          name: t.name,\n          value: n.replace(on, \"\\r\\n\")\n        };\n      }).get();\n    }\n  }), v.param = function (e, n) {\n    var r,\n        i = [],\n        s = function (e, t) {\n      t = v.isFunction(t) ? t() : t == null ? \"\" : t, i[i.length] = encodeURIComponent(e) + \"=\" + encodeURIComponent(t);\n    };\n\n    n === t && (n = v.ajaxSettings && v.ajaxSettings.traditional);\n    if (v.isArray(e) || e.jquery && !v.isPlainObject(e)) v.each(e, function () {\n      s(this.name, this.value);\n    });else for (r in e) fn(r, e[r], n, s);\n    return i.join(\"&\").replace(rn, \"+\");\n  };\n  var ln,\n      cn,\n      hn = /#.*$/,\n      pn = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n      dn = /^(?:about|app|app\\-storage|.+\\-extension|file|res|widget):$/,\n      vn = /^(?:GET|HEAD)$/,\n      mn = /^\\/\\//,\n      gn = /\\?/,\n      yn = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      bn = /([?&])_=[^&]*/,\n      wn = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n      En = v.fn.load,\n      Sn = {},\n      xn = {},\n      Tn = [\"*/\"] + [\"*\"];\n\n  try {\n    cn = s.href;\n  } catch (Nn) {\n    cn = i.createElement(\"a\"), cn.href = \"\", cn = cn.href;\n  }\n\n  ln = wn.exec(cn.toLowerCase()) || [], v.fn.load = function (e, n, r) {\n    if (typeof e != \"string\" && En) return En.apply(this, arguments);\n    if (!this.length) return this;\n    var i,\n        s,\n        o,\n        u = this,\n        a = e.indexOf(\" \");\n    return a >= 0 && (i = e.slice(a, e.length), e = e.slice(0, a)), v.isFunction(n) ? (r = n, n = t) : n && typeof n == \"object\" && (s = \"POST\"), v.ajax({\n      url: e,\n      type: s,\n      dataType: \"html\",\n      data: n,\n      complete: function (e, t) {\n        r && u.each(r, o || [e.responseText, t, e]);\n      }\n    }).done(function (e) {\n      o = arguments, u.html(i ? v(\"<div>\").append(e.replace(yn, \"\")).find(i) : e);\n    }), this;\n  }, v.each(\"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"), function (e, t) {\n    v.fn[t] = function (e) {\n      return this.on(t, e);\n    };\n  }), v.each([\"get\", \"post\"], function (e, n) {\n    v[n] = function (e, r, i, s) {\n      return v.isFunction(r) && (s = s || i, i = r, r = t), v.ajax({\n        type: n,\n        url: e,\n        data: r,\n        success: i,\n        dataType: s\n      });\n    };\n  }), v.extend({\n    getScript: function (e, n) {\n      return v.get(e, t, n, \"script\");\n    },\n    getJSON: function (e, t, n) {\n      return v.get(e, t, n, \"json\");\n    },\n    ajaxSetup: function (e, t) {\n      return t ? Ln(e, v.ajaxSettings) : (t = e, e = v.ajaxSettings), Ln(e, t), e;\n    },\n    ajaxSettings: {\n      url: cn,\n      isLocal: dn.test(ln[1]),\n      global: !0,\n      type: \"GET\",\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n      processData: !0,\n      async: !0,\n      accepts: {\n        xml: \"application/xml, text/xml\",\n        html: \"text/html\",\n        text: \"text/plain\",\n        json: \"application/json, text/javascript\",\n        \"*\": Tn\n      },\n      contents: {\n        xml: /xml/,\n        html: /html/,\n        json: /json/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\"\n      },\n      converters: {\n        \"* text\": e.String,\n        \"text html\": !0,\n        \"text json\": v.parseJSON,\n        \"text xml\": v.parseXML\n      },\n      flatOptions: {\n        context: !0,\n        url: !0\n      }\n    },\n    ajaxPrefilter: Cn(Sn),\n    ajaxTransport: Cn(xn),\n    ajax: function (e, n) {\n      function T(e, n, s, a) {\n        var l,\n            y,\n            b,\n            w,\n            S,\n            T = n;\n        if (E === 2) return;\n        E = 2, u && clearTimeout(u), o = t, i = a || \"\", x.readyState = e > 0 ? 4 : 0, s && (w = An(c, x, s));\n        if (e >= 200 && e < 300 || e === 304) c.ifModified && (S = x.getResponseHeader(\"Last-Modified\"), S && (v.lastModified[r] = S), S = x.getResponseHeader(\"Etag\"), S && (v.etag[r] = S)), e === 304 ? (T = \"notmodified\", l = !0) : (l = On(c, w), T = l.state, y = l.data, b = l.error, l = !b);else {\n          b = T;\n          if (!T || e) T = \"error\", e < 0 && (e = 0);\n        }\n        x.status = e, x.statusText = (n || T) + \"\", l ? d.resolveWith(h, [y, T, x]) : d.rejectWith(h, [x, T, b]), x.statusCode(g), g = t, f && p.trigger(\"ajax\" + (l ? \"Success\" : \"Error\"), [x, c, l ? y : b]), m.fireWith(h, [x, T]), f && (p.trigger(\"ajaxComplete\", [x, c]), --v.active || v.event.trigger(\"ajaxStop\"));\n      }\n\n      typeof e == \"object\" && (n = e, e = t), n = n || {};\n      var r,\n          i,\n          s,\n          o,\n          u,\n          a,\n          f,\n          l,\n          c = v.ajaxSetup({}, n),\n          h = c.context || c,\n          p = h !== c && (h.nodeType || h instanceof v) ? v(h) : v.event,\n          d = v.Deferred(),\n          m = v.Callbacks(\"once memory\"),\n          g = c.statusCode || {},\n          b = {},\n          w = {},\n          E = 0,\n          S = \"canceled\",\n          x = {\n        readyState: 0,\n        setRequestHeader: function (e, t) {\n          if (!E) {\n            var n = e.toLowerCase();\n            e = w[n] = w[n] || e, b[e] = t;\n          }\n\n          return this;\n        },\n        getAllResponseHeaders: function () {\n          return E === 2 ? i : null;\n        },\n        getResponseHeader: function (e) {\n          var n;\n\n          if (E === 2) {\n            if (!s) {\n              s = {};\n\n              while (n = pn.exec(i)) s[n[1].toLowerCase()] = n[2];\n            }\n\n            n = s[e.toLowerCase()];\n          }\n\n          return n === t ? null : n;\n        },\n        overrideMimeType: function (e) {\n          return E || (c.mimeType = e), this;\n        },\n        abort: function (e) {\n          return e = e || S, o && o.abort(e), T(0, e), this;\n        }\n      };\n      d.promise(x), x.success = x.done, x.error = x.fail, x.complete = m.add, x.statusCode = function (e) {\n        if (e) {\n          var t;\n          if (E < 2) for (t in e) g[t] = [g[t], e[t]];else t = e[x.status], x.always(t);\n        }\n\n        return this;\n      }, c.url = ((e || c.url) + \"\").replace(hn, \"\").replace(mn, ln[1] + \"//\"), c.dataTypes = v.trim(c.dataType || \"*\").toLowerCase().split(y), c.crossDomain == null && (a = wn.exec(c.url.toLowerCase()), c.crossDomain = !(!a || a[1] === ln[1] && a[2] === ln[2] && (a[3] || (a[1] === \"http:\" ? 80 : 443)) == (ln[3] || (ln[1] === \"http:\" ? 80 : 443)))), c.data && c.processData && typeof c.data != \"string\" && (c.data = v.param(c.data, c.traditional)), kn(Sn, c, n, x);\n      if (E === 2) return x;\n      f = c.global, c.type = c.type.toUpperCase(), c.hasContent = !vn.test(c.type), f && v.active++ === 0 && v.event.trigger(\"ajaxStart\");\n\n      if (!c.hasContent) {\n        c.data && (c.url += (gn.test(c.url) ? \"&\" : \"?\") + c.data, delete c.data), r = c.url;\n\n        if (c.cache === !1) {\n          var N = v.now(),\n              C = c.url.replace(bn, \"$1_=\" + N);\n          c.url = C + (C === c.url ? (gn.test(c.url) ? \"&\" : \"?\") + \"_=\" + N : \"\");\n        }\n      }\n\n      (c.data && c.hasContent && c.contentType !== !1 || n.contentType) && x.setRequestHeader(\"Content-Type\", c.contentType), c.ifModified && (r = r || c.url, v.lastModified[r] && x.setRequestHeader(\"If-Modified-Since\", v.lastModified[r]), v.etag[r] && x.setRequestHeader(\"If-None-Match\", v.etag[r])), x.setRequestHeader(\"Accept\", c.dataTypes[0] && c.accepts[c.dataTypes[0]] ? c.accepts[c.dataTypes[0]] + (c.dataTypes[0] !== \"*\" ? \", \" + Tn + \"; q=0.01\" : \"\") : c.accepts[\"*\"]);\n\n      for (l in c.headers) x.setRequestHeader(l, c.headers[l]);\n\n      if (!c.beforeSend || c.beforeSend.call(h, x, c) !== !1 && E !== 2) {\n        S = \"abort\";\n\n        for (l in {\n          success: 1,\n          error: 1,\n          complete: 1\n        }) x[l](c[l]);\n\n        o = kn(xn, c, n, x);\n        if (!o) T(-1, \"No Transport\");else {\n          x.readyState = 1, f && p.trigger(\"ajaxSend\", [x, c]), c.async && c.timeout > 0 && (u = setTimeout(function () {\n            x.abort(\"timeout\");\n          }, c.timeout));\n\n          try {\n            E = 1, o.send(b, T);\n          } catch (k) {\n            if (!(E < 2)) throw k;\n            T(-1, k);\n          }\n        }\n        return x;\n      }\n\n      return x.abort();\n    },\n    active: 0,\n    lastModified: {},\n    etag: {}\n  });\n  var Mn = [],\n      _n = /\\?/,\n      Dn = /(=)\\?(?=&|$)|\\?\\?/,\n      Pn = v.now();\n  v.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function () {\n      var e = Mn.pop() || v.expando + \"_\" + Pn++;\n      return this[e] = !0, e;\n    }\n  }), v.ajaxPrefilter(\"json jsonp\", function (n, r, i) {\n    var s,\n        o,\n        u,\n        a = n.data,\n        f = n.url,\n        l = n.jsonp !== !1,\n        c = l && Dn.test(f),\n        h = l && !c && typeof a == \"string\" && !(n.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Dn.test(a);\n    if (n.dataTypes[0] === \"jsonp\" || c || h) return s = n.jsonpCallback = v.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, o = e[s], c ? n.url = f.replace(Dn, \"$1\" + s) : h ? n.data = a.replace(Dn, \"$1\" + s) : l && (n.url += (_n.test(f) ? \"&\" : \"?\") + n.jsonp + \"=\" + s), n.converters[\"script json\"] = function () {\n      return u || v.error(s + \" was not called\"), u[0];\n    }, n.dataTypes[0] = \"json\", e[s] = function () {\n      u = arguments;\n    }, i.always(function () {\n      e[s] = o, n[s] && (n.jsonpCallback = r.jsonpCallback, Mn.push(s)), u && v.isFunction(o) && o(u[0]), u = o = t;\n    }), \"script\";\n  }), v.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /javascript|ecmascript/\n    },\n    converters: {\n      \"text script\": function (e) {\n        return v.globalEval(e), e;\n      }\n    }\n  }), v.ajaxPrefilter(\"script\", function (e) {\n    e.cache === t && (e.cache = !1), e.crossDomain && (e.type = \"GET\", e.global = !1);\n  }), v.ajaxTransport(\"script\", function (e) {\n    if (e.crossDomain) {\n      var n,\n          r = i.head || i.getElementsByTagName(\"head\")[0] || i.documentElement;\n      return {\n        send: function (s, o) {\n          n = i.createElement(\"script\"), n.async = \"async\", e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, i) {\n            if (i || !n.readyState || /loaded|complete/.test(n.readyState)) n.onload = n.onreadystatechange = null, r && n.parentNode && r.removeChild(n), n = t, i || o(200, \"success\");\n          }, r.insertBefore(n, r.firstChild);\n        },\n        abort: function () {\n          n && n.onload(0, 1);\n        }\n      };\n    }\n  });\n  var Hn,\n      Bn = e.ActiveXObject ? function () {\n    for (var e in Hn) Hn[e](0, 1);\n  } : !1,\n      jn = 0;\n  v.ajaxSettings.xhr = e.ActiveXObject ? function () {\n    return !this.isLocal && Fn() || In();\n  } : Fn, function (e) {\n    v.extend(v.support, {\n      ajax: !!e,\n      cors: !!e && \"withCredentials\" in e\n    });\n  }(v.ajaxSettings.xhr()), v.support.ajax && v.ajaxTransport(function (n) {\n    if (!n.crossDomain || v.support.cors) {\n      var r;\n      return {\n        send: function (i, s) {\n          var o,\n              u,\n              a = n.xhr();\n          n.username ? a.open(n.type, n.url, n.async, n.username, n.password) : a.open(n.type, n.url, n.async);\n          if (n.xhrFields) for (u in n.xhrFields) a[u] = n.xhrFields[u];\n          n.mimeType && a.overrideMimeType && a.overrideMimeType(n.mimeType), !n.crossDomain && !i[\"X-Requested-With\"] && (i[\"X-Requested-With\"] = \"XMLHttpRequest\");\n\n          try {\n            for (u in i) a.setRequestHeader(u, i[u]);\n          } catch (f) {}\n\n          a.send(n.hasContent && n.data || null), r = function (e, i) {\n            var u, f, l, c, h;\n\n            try {\n              if (r && (i || a.readyState === 4)) {\n                r = t, o && (a.onreadystatechange = v.noop, Bn && delete Hn[o]);\n                if (i) a.readyState !== 4 && a.abort();else {\n                  u = a.status, l = a.getAllResponseHeaders(), c = {}, h = a.responseXML, h && h.documentElement && (c.xml = h);\n\n                  try {\n                    c.text = a.responseText;\n                  } catch (p) {}\n\n                  try {\n                    f = a.statusText;\n                  } catch (p) {\n                    f = \"\";\n                  }\n\n                  !u && n.isLocal && !n.crossDomain ? u = c.text ? 200 : 404 : u === 1223 && (u = 204);\n                }\n              }\n            } catch (d) {\n              i || s(-1, d);\n            }\n\n            c && s(u, f, c, l);\n          }, n.async ? a.readyState === 4 ? setTimeout(r, 0) : (o = ++jn, Bn && (Hn || (Hn = {}, v(e).unload(Bn)), Hn[o] = r), a.onreadystatechange = r) : r();\n        },\n        abort: function () {\n          r && r(0, 1);\n        }\n      };\n    }\n  });\n  var qn,\n      Rn,\n      Un = /^(?:toggle|show|hide)$/,\n      zn = new RegExp(\"^(?:([-+])=|)(\" + m + \")([a-z%]*)$\", \"i\"),\n      Wn = /queueHooks$/,\n      Xn = [Gn],\n      Vn = {\n    \"*\": [function (e, t) {\n      var n,\n          r,\n          i = this.createTween(e, t),\n          s = zn.exec(t),\n          o = i.cur(),\n          u = +o || 0,\n          a = 1,\n          f = 20;\n\n      if (s) {\n        n = +s[2], r = s[3] || (v.cssNumber[e] ? \"\" : \"px\");\n\n        if (r !== \"px\" && u) {\n          u = v.css(i.elem, e, !0) || n || 1;\n\n          do a = a || \".5\", u /= a, v.style(i.elem, e, u + r); while (a !== (a = i.cur() / o) && a !== 1 && --f);\n        }\n\n        i.unit = r, i.start = u, i.end = s[1] ? u + (s[1] + 1) * n : n;\n      }\n\n      return i;\n    }]\n  };\n  v.Animation = v.extend(Kn, {\n    tweener: function (e, t) {\n      v.isFunction(e) ? (t = e, e = [\"*\"]) : e = e.split(\" \");\n      var n,\n          r = 0,\n          i = e.length;\n\n      for (; r < i; r++) n = e[r], Vn[n] = Vn[n] || [], Vn[n].unshift(t);\n    },\n    prefilter: function (e, t) {\n      t ? Xn.unshift(e) : Xn.push(e);\n    }\n  }), v.Tween = Yn, Yn.prototype = {\n    constructor: Yn,\n    init: function (e, t, n, r, i, s) {\n      this.elem = e, this.prop = n, this.easing = i || \"swing\", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = s || (v.cssNumber[n] ? \"\" : \"px\");\n    },\n    cur: function () {\n      var e = Yn.propHooks[this.prop];\n      return e && e.get ? e.get(this) : Yn.propHooks._default.get(this);\n    },\n    run: function (e) {\n      var t,\n          n = Yn.propHooks[this.prop];\n      return this.options.duration ? this.pos = t = v.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Yn.propHooks._default.set(this), this;\n    }\n  }, Yn.prototype.init.prototype = Yn.prototype, Yn.propHooks = {\n    _default: {\n      get: function (e) {\n        var t;\n        return e.elem[e.prop] == null || !!e.elem.style && e.elem.style[e.prop] != null ? (t = v.css(e.elem, e.prop, !1, \"\"), !t || t === \"auto\" ? 0 : t) : e.elem[e.prop];\n      },\n      set: function (e) {\n        v.fx.step[e.prop] ? v.fx.step[e.prop](e) : e.elem.style && (e.elem.style[v.cssProps[e.prop]] != null || v.cssHooks[e.prop]) ? v.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now;\n      }\n    }\n  }, Yn.propHooks.scrollTop = Yn.propHooks.scrollLeft = {\n    set: function (e) {\n      e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);\n    }\n  }, v.each([\"toggle\", \"show\", \"hide\"], function (e, t) {\n    var n = v.fn[t];\n\n    v.fn[t] = function (r, i, s) {\n      return r == null || typeof r == \"boolean\" || !e && v.isFunction(r) && v.isFunction(i) ? n.apply(this, arguments) : this.animate(Zn(t, !0), r, i, s);\n    };\n  }), v.fn.extend({\n    fadeTo: function (e, t, n, r) {\n      return this.filter(Gt).css(\"opacity\", 0).show().end().animate({\n        opacity: t\n      }, e, n, r);\n    },\n    animate: function (e, t, n, r) {\n      var i = v.isEmptyObject(e),\n          s = v.speed(t, n, r),\n          o = function () {\n        var t = Kn(this, v.extend({}, e), s);\n        i && t.stop(!0);\n      };\n\n      return i || s.queue === !1 ? this.each(o) : this.queue(s.queue, o);\n    },\n    stop: function (e, n, r) {\n      var i = function (e) {\n        var t = e.stop;\n        delete e.stop, t(r);\n      };\n\n      return typeof e != \"string\" && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || \"fx\", []), this.each(function () {\n        var t = !0,\n            n = e != null && e + \"queueHooks\",\n            s = v.timers,\n            o = v._data(this);\n\n        if (n) o[n] && o[n].stop && i(o[n]);else for (n in o) o[n] && o[n].stop && Wn.test(n) && i(o[n]);\n\n        for (n = s.length; n--;) s[n].elem === this && (e == null || s[n].queue === e) && (s[n].anim.stop(r), t = !1, s.splice(n, 1));\n\n        (t || !r) && v.dequeue(this, e);\n      });\n    }\n  }), v.each({\n    slideDown: Zn(\"show\"),\n    slideUp: Zn(\"hide\"),\n    slideToggle: Zn(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (e, t) {\n    v.fn[e] = function (e, n, r) {\n      return this.animate(t, e, n, r);\n    };\n  }), v.speed = function (e, t, n) {\n    var r = e && typeof e == \"object\" ? v.extend({}, e) : {\n      complete: n || !n && t || v.isFunction(e) && e,\n      duration: e,\n      easing: n && t || t && !v.isFunction(t) && t\n    };\n    r.duration = v.fx.off ? 0 : typeof r.duration == \"number\" ? r.duration : r.duration in v.fx.speeds ? v.fx.speeds[r.duration] : v.fx.speeds._default;\n    if (r.queue == null || r.queue === !0) r.queue = \"fx\";\n    return r.old = r.complete, r.complete = function () {\n      v.isFunction(r.old) && r.old.call(this), r.queue && v.dequeue(this, r.queue);\n    }, r;\n  }, v.easing = {\n    linear: function (e) {\n      return e;\n    },\n    swing: function (e) {\n      return .5 - Math.cos(e * Math.PI) / 2;\n    }\n  }, v.timers = [], v.fx = Yn.prototype.init, v.fx.tick = function () {\n    var e,\n        n = v.timers,\n        r = 0;\n    qn = v.now();\n\n    for (; r < n.length; r++) e = n[r], !e() && n[r] === e && n.splice(r--, 1);\n\n    n.length || v.fx.stop(), qn = t;\n  }, v.fx.timer = function (e) {\n    e() && v.timers.push(e) && !Rn && (Rn = setInterval(v.fx.tick, v.fx.interval));\n  }, v.fx.interval = 13, v.fx.stop = function () {\n    clearInterval(Rn), Rn = null;\n  }, v.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    _default: 400\n  }, v.fx.step = {}, v.expr && v.expr.filters && (v.expr.filters.animated = function (e) {\n    return v.grep(v.timers, function (t) {\n      return e === t.elem;\n    }).length;\n  });\n  var er = /^(?:body|html)$/i;\n  v.fn.offset = function (e) {\n    if (arguments.length) return e === t ? this : this.each(function (t) {\n      v.offset.setOffset(this, e, t);\n    });\n    var n,\n        r,\n        i,\n        s,\n        o,\n        u,\n        a,\n        f = {\n      top: 0,\n      left: 0\n    },\n        l = this[0],\n        c = l && l.ownerDocument;\n    if (!c) return;\n    return (r = c.body) === l ? v.offset.bodyOffset(l) : (n = c.documentElement, v.contains(n, l) ? (typeof l.getBoundingClientRect != \"undefined\" && (f = l.getBoundingClientRect()), i = tr(c), s = n.clientTop || r.clientTop || 0, o = n.clientLeft || r.clientLeft || 0, u = i.pageYOffset || n.scrollTop, a = i.pageXOffset || n.scrollLeft, {\n      top: f.top + u - s,\n      left: f.left + a - o\n    }) : f);\n  }, v.offset = {\n    bodyOffset: function (e) {\n      var t = e.offsetTop,\n          n = e.offsetLeft;\n      return v.support.doesNotIncludeMarginInBodyOffset && (t += parseFloat(v.css(e, \"marginTop\")) || 0, n += parseFloat(v.css(e, \"marginLeft\")) || 0), {\n        top: t,\n        left: n\n      };\n    },\n    setOffset: function (e, t, n) {\n      var r = v.css(e, \"position\");\n      r === \"static\" && (e.style.position = \"relative\");\n      var i = v(e),\n          s = i.offset(),\n          o = v.css(e, \"top\"),\n          u = v.css(e, \"left\"),\n          a = (r === \"absolute\" || r === \"fixed\") && v.inArray(\"auto\", [o, u]) > -1,\n          f = {},\n          l = {},\n          c,\n          h;\n      a ? (l = i.position(), c = l.top, h = l.left) : (c = parseFloat(o) || 0, h = parseFloat(u) || 0), v.isFunction(t) && (t = t.call(e, n, s)), t.top != null && (f.top = t.top - s.top + c), t.left != null && (f.left = t.left - s.left + h), \"using\" in t ? t.using.call(e, f) : i.css(f);\n    }\n  }, v.fn.extend({\n    position: function () {\n      if (!this[0]) return;\n      var e = this[0],\n          t = this.offsetParent(),\n          n = this.offset(),\n          r = er.test(t[0].nodeName) ? {\n        top: 0,\n        left: 0\n      } : t.offset();\n      return n.top -= parseFloat(v.css(e, \"marginTop\")) || 0, n.left -= parseFloat(v.css(e, \"marginLeft\")) || 0, r.top += parseFloat(v.css(t[0], \"borderTopWidth\")) || 0, r.left += parseFloat(v.css(t[0], \"borderLeftWidth\")) || 0, {\n        top: n.top - r.top,\n        left: n.left - r.left\n      };\n    },\n    offsetParent: function () {\n      return this.map(function () {\n        var e = this.offsetParent || i.body;\n\n        while (e && !er.test(e.nodeName) && v.css(e, \"position\") === \"static\") e = e.offsetParent;\n\n        return e || i.body;\n      });\n    }\n  }), v.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (e, n) {\n    var r = /Y/.test(n);\n\n    v.fn[e] = function (i) {\n      return v.access(this, function (e, i, s) {\n        var o = tr(e);\n        if (s === t) return o ? n in o ? o[n] : o.document.documentElement[i] : e[i];\n        o ? o.scrollTo(r ? v(o).scrollLeft() : s, r ? s : v(o).scrollTop()) : e[i] = s;\n      }, e, i, arguments.length, null);\n    };\n  }), v.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (e, n) {\n    v.each({\n      padding: \"inner\" + e,\n      content: n,\n      \"\": \"outer\" + e\n    }, function (r, i) {\n      v.fn[i] = function (i, s) {\n        var o = arguments.length && (r || typeof i != \"boolean\"),\n            u = r || (i === !0 || s === !0 ? \"margin\" : \"border\");\n        return v.access(this, function (n, r, i) {\n          var s;\n          return v.isWindow(n) ? n.document.documentElement[\"client\" + e] : n.nodeType === 9 ? (s = n.documentElement, Math.max(n.body[\"scroll\" + e], s[\"scroll\" + e], n.body[\"offset\" + e], s[\"offset\" + e], s[\"client\" + e])) : i === t ? v.css(n, r, i, u) : v.style(n, r, i, u);\n        }, n, o ? i : t, o, null);\n      };\n    });\n  }), e.jQuery = e.$ = v,  true && __webpack_require__.amdO.jQuery && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return v;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n})(window);\n\n//# sourceURL=webpack://loading-page/./src/js/jquery-1.8.3.min.js?");

/***/ }),

/***/ "./src/js/lrtk.js":
/*!************************!*\
  !*** ./src/js/lrtk.js ***!
  \************************/
/***/ (() => {

eval("/*\n * @Author: your name\n * @Date: 2021-03-07 18:16:04\n * @LastEditTime: 2021-03-28 19:03:08\n * @LastEditors: Please set LastEditors\n * @Description: In User Settings Edit\n * @FilePath: /safe-lawyer/loading-page/src/js/lrtk.js\n */\n$(function () {\n  var tophtml = \"<div id=\\\"izl_rmenu\\\" class=\\\"izl-rmenu\\\"><a href=\\\"http://wpa.qq.com/msgrd?v=3&amp;uin=1838301961&amp;site=qq&amp;menu=yes\\\" class=\\\"btn btn-qq\\\" target=\\\"_blank\\\"></a><div class=\\\"btn btn-wx\\\"><img class=\\\"pic\\\" src=\\\"https://tva1.sinaimg.cn/large/008eGmZEly1goydgpqqdpj30by0by752.jpg\\\" onclick=\\\"window.location.href=\\'http://www.safe-lawyer.com\\'\\\"/></div><div class=\\\"btn btn-phone\\\"><div class=\\\"phone\\\"><a href=\\\"tel:15801479466\\\" style=\\\"color: #fff;\\\">15801479466</a></div></div><div class=\\\"btn btn-top\\\"></div></div>\";\n  $(\"#top\").html(tophtml);\n  $(\"#izl_rmenu\").each(function () {\n    $(this).find(\".btn-wx\").mouseenter(function () {\n      $(this).find(\".pic\").fadeIn(\"fast\");\n    });\n    $(this).find(\".btn-wx\").mouseleave(function () {\n      $(this).find(\".pic\").fadeOut(\"fast\");\n    });\n    $(this).find(\".btn-phone\").mouseenter(function () {\n      $(this).find(\".phone\").fadeIn(\"fast\");\n    });\n    $(this).find(\".btn-phone\").mouseleave(function () {\n      $(this).find(\".phone\").fadeOut(\"fast\");\n    });\n    $(this).find(\".btn-top\").click(function () {\n      $(\"html, body\").animate({\n        \"scroll-top\": 0\n      }, \"fast\");\n    });\n  });\n  var lastRmenuStatus = false;\n  $(window).scroll(function () {\n    //bug\n    var _top = $(window).scrollTop();\n\n    if (_top > 200) {\n      $(\"#izl_rmenu\").data(\"expanded\", true);\n    } else {\n      $(\"#izl_rmenu\").data(\"expanded\", false);\n    }\n\n    if ($(\"#izl_rmenu\").data(\"expanded\") != lastRmenuStatus) {\n      lastRmenuStatus = $(\"#izl_rmenu\").data(\"expanded\");\n\n      if (lastRmenuStatus) {\n        $(\"#izl_rmenu .btn-top\").slideDown();\n      } else {\n        $(\"#izl_rmenu .btn-top\").slideUp();\n      }\n    }\n  });\n});\n\n//# sourceURL=webpack://loading-page/./src/js/lrtk.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _splidejs_splide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @splidejs/splide */ \"./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/js/splide.esm.js\");\n/* harmony import */ var _splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_splidejs_splide__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * @Author: your name\n * @Date: 2021-03-07 16:05:09\n * @LastEditTime: 2021-03-28 20:56:19\n * @LastEditors: Please set LastEditors\n * @Description: In User Settings Edit\n * @FilePath: /safe-lawyer/loading-page/src/main.js\n */\n__webpack_require__(/*! ./css/a8.css */ \"./src/css/a8.css\");\n\n__webpack_require__(/*! ./css/animate.css */ \"./src/css/animate.css\");\n\n__webpack_require__(/*! ./css/menu.css */ \"./src/css/menu.css\");\n\n__webpack_require__(/*! ./css/lrtk.css */ \"./src/css/lrtk.css\");\n\n__webpack_require__(/*! !style-loader!css-loader!./css/mycss.css */ \"./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./src/css/mycss.css\"); // import myCss from '!style-loader!css-loader!./css/mycss.css'\n\n\n__webpack_require__(/*! ./js/jquery-1.8.3.min.js */ \"./src/js/jquery-1.8.3.min.js\"); // require('./js/menufixed.js')\n\n\n__webpack_require__(/*! ./js/lrtk.js */ \"./src/js/lrtk.js\"); // require('./js/wow.min.js')\n// <!--飞入特效-->\n// new WOW().init();\n// images\n\n\n__webpack_require__(/*! ./images/fo_ad.png */ \"./src/images/fo_ad.png\"); // You should import the CSS file.\n\n\n__webpack_require__(/*! !style-loader!css-loader!@splidejs/splide/dist/css/splide.min.css */ \"./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css\");\n\n // let template = require('./tpl/main.ejs')\n// let data = require('./conf/data.json')\n// document.getElementById('myapp').innerHTML = template(data);\n// mdc text field\n\nlet username = document.querySelector('#username');\nlet mobile = document.querySelector('#mobile');\nlet company = document.querySelector('#company');\nlet message = document.querySelector('#message');\nlet form = document.getElementById('form');\nmdc.textField.MDCTextField.attachTo(username);\nmdc.textField.MDCTextField.attachTo(mobile);\nmdc.textField.MDCTextField.attachTo(company);\nmdc.textField.MDCTextField.attachTo(message);\n\nfunction clearForm() {\n  form.reset();\n} // View a list of images.\n\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  new (_splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default())('#images', {\n    type: 'loop',\n    perPage: 1,\n    autoplay: true,\n    pauseOnHover: true\n  }).mount();\n}); // submit signup\n\ndocument.querySelector('#signup-button').addEventListener('click', function (event) {\n  let username_val = username.querySelector('[name=username]').value;\n  let mobile_val = mobile.querySelector('[name=mobile]').value;\n  let company_val = company.querySelector('[name=company]').value;\n  let message_val = message.querySelector('[name=message]').value;\n  let start_at_val = form.querySelector('[name=start_at]:checked').value;\n\n  if (username_val.trim() === \"\" || mobile_val.trim() === '' || company_val.trim() === '' || start_at_val.trim() === '') {\n    alert('请填写完整报名信息！');\n    return;\n  }\n\n  if (!/^1[3456789]\\d{9}$/.test(mobile_val)) {\n    alert('手机号格式错误！');\n    return;\n  } // alert(JSON.stringify());\n\n\n  $.ajax({\n    type: \"POST\",\n    dataType: 'json',\n    url: \"submit.php\",\n    data: {\n      username_val,\n      mobile_val,\n      company_val,\n      message_val,\n      start_at_val\n    }\n  }).success(function ({\n    code,\n    msg\n  }) {\n    // console.log(code, msg);\n    clearForm();\n\n    if (code === 10000) {\n      alert(msg);\n      return;\n    }\n\n    alert(msg);\n  }).fail(function () {\n    // clearForm();\n    alert('报名出了点异常，请重试！');\n  });\n});\n\n//# sourceURL=webpack://loading-page/./src/main.js?");

/***/ }),

/***/ "./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../../css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"@keyframes splide-loading{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.splide__container{position:relative;box-sizing:border-box}.splide__list{margin:0!important;padding:0!important;width:-webkit-max-content;width:max-content;will-change:transform}.splide.is-active .splide__list{display:flex}.splide__pagination{display:inline-flex;align-items:center;width:95%;flex-wrap:wrap;justify-content:center;margin:0}.splide__pagination li{list-style-type:none;display:inline-block;line-height:1;margin:0}.splide{visibility:hidden}.splide,.splide__slide{position:relative;outline:none}.splide__slide{box-sizing:border-box;list-style-type:none!important;margin:0;flex-shrink:0}.splide__slide img{vertical-align:bottom}.splide__slider{position:relative}.splide__spinner{position:absolute;top:0;left:0;right:0;bottom:0;margin:auto;display:inline-block;width:20px;height:20px;border-radius:50%;border:2px solid #999;border-left-color:transparent;animation:splide-loading 1s linear infinite}.splide__track{position:relative;z-index:0;overflow:hidden}.splide--draggable>.splide__track>.splide__list>.splide__slide{-webkit-user-select:none;user-select:none}.splide--fade>.splide__track>.splide__list{display:block}.splide--fade>.splide__track>.splide__list>.splide__slide{position:absolute;top:0;left:0;z-index:0;opacity:0}.splide--fade>.splide__track>.splide__list>.splide__slide.is-active{position:relative;z-index:1;opacity:1}.splide--rtl{direction:rtl}.splide--ttb>.splide__track>.splide__list{display:block}.splide--ttb>.splide__pagination{width:auto}.splide__arrow{position:absolute;z-index:1;top:50%;transform:translateY(-50%);width:2em;height:2em;border-radius:50%;display:flex;align-items:center;justify-content:center;border:none;padding:0;opacity:.7;background:#ccc}.splide__arrow svg{width:1.2em;height:1.2em}.splide__arrow:hover{cursor:pointer;opacity:.9}.splide__arrow:focus{outline:none}.splide__arrow--prev{left:1em}.splide__arrow--prev svg{transform:scaleX(-1)}.splide__arrow--next{right:1em}.splide__pagination{position:absolute;z-index:1;bottom:.5em;left:50%;transform:translateX(-50%);padding:0}.splide__pagination__page{display:inline-block;width:8px;height:8px;background:#ccc;border-radius:50%;margin:3px;padding:0;transition:transform .2s linear;border:none;opacity:.7}.splide__pagination__page.is-active{transform:scale(1.4);background:#fff}.splide__pagination__page:hover{cursor:pointer;opacity:.9}.splide__pagination__page:focus{outline:none}.splide__progress__bar{width:0;height:3px;background:#ccc}.splide--nav>.splide__track>.splide__list>.splide__slide{border:3px solid transparent}.splide--nav>.splide__track>.splide__list>.splide__slide.is-active{border-color:#000}.splide--nav>.splide__track>.splide__list>.splide__slide:focus{outline:none}.splide--rtl>.splide__arrows .splide__arrow--prev,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--prev{right:1em;left:auto}.splide--rtl>.splide__arrows .splide__arrow--prev svg,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--prev svg{transform:scaleX(1)}.splide--rtl>.splide__arrows .splide__arrow--next,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--next{left:1em;right:auto}.splide--rtl>.splide__arrows .splide__arrow--next svg,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--next svg{transform:scaleX(-1)}.splide--ttb>.splide__arrows .splide__arrow,.splide--ttb>.splide__track>.splide__arrows .splide__arrow{left:50%;transform:translate(-50%)}.splide--ttb>.splide__arrows .splide__arrow--prev,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--prev{top:1em}.splide--ttb>.splide__arrows .splide__arrow--prev svg,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--prev svg{transform:rotate(-90deg)}.splide--ttb>.splide__arrows .splide__arrow--next,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--next{top:auto;bottom:1em}.splide--ttb>.splide__arrows .splide__arrow--next svg,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--next svg{transform:rotate(90deg)}.splide--ttb>.splide__pagination{display:flex;flex-direction:column;bottom:50%;left:auto;right:.5em;transform:translateY(50%)}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://loading-page/./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css?./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./src/css/mycss.css":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./src/css/mycss.css ***!
  \********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_pnpm_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_pnpm_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_pnpm_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".main {\\n    width: 80%;\\n    vertical-align: middle;\\n    padding: 0 10% 0 10%;\\n    background: azure;\\n}\\n.lawyer-img {\\n    float: left; \\n    margin-left: 2%;\\n    margin-right: 2%;\\n    width: 40%;\\n}\\n\\n.lawyer-img img {\\n    width: 100%;\\n}\\n\\n.lawyer-info {\\n    font-size: 17px;\\n    float: right;\\n    width: 55%;\\n}\\n\\n.lawyer-info p {\\n    line-height: 35px;\\n    padding: 0 100px 15px 0;\\n}\\n\\n@media (min-width: 450px) {\\n    .lawyer-img {\\n        float: left; \\n        margin-left: 2%;\\n        margin-right: 2%;\\n        width: 40%;\\n    }\\n    \\n    .lawyer-info {\\n        font-size: 17px;\\n        float: right;\\n        width: 55%;\\n    }\\n}\\n\\n@media (max-width: 450px) {\\n    .lawyer-img {\\n        margin-left: 2%;\\n        margin-right: 2%;\\n        width: 96%;\\n    }\\n    \\n    .lawyer-info {\\n        font-size: 17px;\\n        padding: 10px;\\n        width: auto;\\n    }\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://loading-page/./src/css/mycss.css?./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/runtime/api.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/runtime/api.js ***!
  \********************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://loading-page/./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./src/css/a8.css":
/*!************************!*\
  !*** ./src/css/a8.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"css/a8.css\");\n\n//# sourceURL=webpack://loading-page/./src/css/a8.css?");

/***/ }),

/***/ "./src/css/animate.css":
/*!*****************************!*\
  !*** ./src/css/animate.css ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"css/animate.css\");\n\n//# sourceURL=webpack://loading-page/./src/css/animate.css?");

/***/ }),

/***/ "./src/css/lrtk.css":
/*!**************************!*\
  !*** ./src/css/lrtk.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"css/lrtk.css\");\n\n//# sourceURL=webpack://loading-page/./src/css/lrtk.css?");

/***/ }),

/***/ "./src/css/menu.css":
/*!**************************!*\
  !*** ./src/css/menu.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"css/menu.css\");\n\n//# sourceURL=webpack://loading-page/./src/css/menu.css?");

/***/ }),

/***/ "./src/images/fo_ad.png":
/*!******************************!*\
  !*** ./src/images/fo_ad.png ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"images-out/fo_ad.png?f500a32dfd0f6032aea14023fb76a59a\");\n\n//# sourceURL=webpack://loading-page/./src/images/fo_ad.png?");

/***/ }),

/***/ "./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css":
/*!************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../../../style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_cjs_js_splide_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../../../css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./splide.min.css */ \"./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_cjs_js_splide_min_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_cjs_js_splide_min_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});\n\n//# sourceURL=webpack://loading-page/./node_modules/.pnpm/@splidejs/splide@2.4.21/node_modules/@splidejs/splide/dist/css/splide.min.css?./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./src/css/mycss.css":
/*!*****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./src/css/mycss.css ***!
  \*****************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_pnpm_style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_pnpm_style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_pnpm_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_cjs_js_mycss_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./mycss.css */ \"./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js!./src/css/mycss.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_pnpm_style_loader_2_0_0_webpack_5_24_3_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_pnpm_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_cjs_js_mycss_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_pnpm_css_loader_5_1_1_webpack_5_24_3_node_modules_css_loader_dist_cjs_js_mycss_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});\n\n//# sourceURL=webpack://loading-page/./src/css/mycss.css?./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/cjs.js!./node_modules/.pnpm/css-loader@5.1.1_webpack@5.24.3/node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \*********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://loading-page/./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.3/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;